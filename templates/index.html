<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VirtualBox虚拟机监控系统</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* 确保页面底部有适当间距 */
        body {
            padding-bottom: 10px;
        }
        
        .status-badge {
            font-size: 0.7em; /* 缩小状态徽章字体 */
        }
        .vm-card {
            transition: all 0.3s ease;
        }
        .vm-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .monitoring-active {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
        }
        .monitoring-inactive {
            background-color: #f8d7da !important;
            border-color: #f5c6cb !important;
        }
        .refresh-spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .auto-refresh {
            background-color: #e7f3ff;
            border-left: 4px solid #007bff;
        }
        
        /* 虚拟机列表容器样式 */
        .vm-list-container {
            height: auto; /* 自动适应高度 */
            max-height: calc(100vh - 500px); /* 增加基础值，确保100%比例下分页控件可见 */
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1rem;
            padding-bottom: 1rem; /* 减少底部内边距，因为有了分页控件 */
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            background-color: #f8f9fa;
            transition: max-height 0.3s ease; /* 添加平滑过渡效果 */
        }
        
        /* 响应式高度调整 */
        @media (max-height: 800px) {
            .vm-list-container {
                max-height: calc(100vh - 450px); /* 增加基础值，确保100%比例下分页控件可见 */
                padding-bottom: 1rem; /* 减少底部内边距 */
            }
            .container-fluid {
                height: calc(100vh - 15px);
                margin-bottom: 15px;
            }
        }
        
        @media (max-height: 600px) {
            .vm-list-container {
                max-height: calc(100vh - 400px); /* 增加基础值，确保100%比例下分页控件可见 */
                padding-bottom: 1rem; /* 减少底部内边距 */
            }
            .container-fluid {
                height: calc(100vh - 10px);
                margin-bottom: 10px;
            }
        }
        
        /* 虚拟机列表滚动条样式 */
        .vm-list-container::-webkit-scrollbar {
            width: 12px;
        }
        
        .vm-list-container::-webkit-scrollbar-track {
            background: #f8f9fa;
            border-radius: 6px;
            margin: 2px;
            border: 1px solid #e9ecef;
        }
        
        .vm-list-container::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #6c757d 0%, #495057 100%);
            border-radius: 6px;
            border: 1px solid #f8f9fa;
            min-height: 40px;
        }
        
        .vm-list-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #495057 0%, #343a40 100%);
        }
        
        .vm-list-container::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, #343a40 0%, #212529 100%);
        }
        
        /* 确保滚动条不会遮挡内容 */
        .vm-list-container {
            scrollbar-gutter: stable;
        }
        
        /* Firefox 滚动条样式 */
        .vm-list-container {
            scrollbar-width: thin;
            scrollbar-color: #6c757d #f8f9fa;
        }
        
        /* 滚动提示样式 */
        #scrollHint {
            position: sticky;
            bottom: 0;
            background: linear-gradient(180deg, transparent 0%, #f8f9fa 50%);
            border-top: 1px solid #dee2e6;
            z-index: 10;
            padding: 0.4rem 0; /* 减少内边距 */
            margin-top: 0.3rem; /* 减少外边距 */
            font-size: 0.75rem; /* 缩小字体 */
        }
        
        /* 分页控件样式 */
        .pagination .page-link {
            color: #007bff;
            border-color: #dee2e6;
        }
        
        .pagination .page-item.active .page-link {
            background-color: #007bff;
            border-color: #007bff;
        }
        
        .pagination .page-item.disabled .page-link {
            color: #6c757d;
            background-color: #fff;
            border-color: #dee2e6;
        }
        
        .pagination .page-link:hover {
            color: #0056b3;
            background-color: #e9ecef;
            border-color: #dee2e6;
        }
        
        /* 确保分页控件始终可见 */
        .d-flex.justify-content-between.align-items-center.mt-3 {
            position: relative;
            z-index: 100;
            background-color: #f8f9fa;
            border-top: 1px solid #dee2e6;
            margin-top: 0 !important;
            padding-top: 0.75rem;
        }
        
        /* 缩小分页控件的字体 */
        .d-flex.justify-content-between.align-items-center.mt-3 .text-muted.small {
            font-size: 0.8rem;
        }
        
        .d-flex.justify-content-between.align-items-center.mt-3 .form-label.small {
            font-size: 0.8rem;
        }
        
        .d-flex.justify-content-between.align-items-center.mt-3 .form-select-sm {
            font-size: 0.8rem;
        }
        
        /* 确保页面整体高度固定，留出底部间距 */
        .container-fluid {
            height: calc(100vh - 20px);
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        /* 去掉右侧最外边滚动条 */
        body {
            overflow-x: hidden;
        }
        
        html {
            overflow-x: hidden;
        }
        
        /* 头部区域固定高度 */
        .bg-primary {
            flex-shrink: 0;
        }
        
        /* 控制面板区域固定高度 */
        .row.mt-3:first-of-type {
            flex-shrink: 0;
        }
        
        /* 虚拟机列表卡片区域 */
        .vm-list-card {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .vm-list-card .card-body {
            flex: 1;
            overflow: hidden;
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        /* 确保虚拟机卡片在滚动容器中正常显示 */
        .vm-list-container .row {
            margin: 0;
            min-height: 100%;
            flex-wrap: wrap;
        }
        
        /* 确保缩放后的卡片布局正确 */
        .vm-list-container .col-md-6,
        .vm-list-container .col-lg-4 {
            display: flex;
            flex-direction: column;
        }
        
        .vm-list-container .vm-card {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .vm-list-container .col-md-6,
        .vm-list-container .col-lg-4 {
            padding: 0.3rem; /* 减少列间距 */
            margin-bottom: 0.3rem; /* 减少底部间距 */
        }
        
        /* 虚拟机卡片在滚动容器中的样式优化 */
        .vm-list-container .vm-card {
            height: auto;
            min-height: 100px; /* 减少最小高度 */
            margin-bottom: 0.3rem; /* 减少卡片间距 */
            transform: scale(0.9); /* 缩小显示比例到90% */
            transform-origin: top left; /* 设置变换原点 */
        }
        
        /* 确保最后一个虚拟机卡片有足够的底部间距 */
        .vm-list-container .vm-card:last-child {
            margin-bottom: 0.5rem; /* 减少最后一个卡片的底部间距 */
        }
        
        /* 优化虚拟机卡片内容布局 */
        .vm-list-container .vm-card .card-body {
            padding: 0.5rem; /* 减少内边距 */
        }
        
        .vm-list-container .vm-card .card-header {
            padding: 0.4rem 0.5rem; /* 减少头部内边距 */
        }
        
        /* 缩小虚拟机卡片内的字体 */
        .vm-list-container .vm-card .card-header h6 {
            font-size: 0.9rem; /* 缩小标题字体 */
        }
        
        .vm-list-container .vm-card .card-body small {
            font-size: 0.8rem; /* 缩小内容字体 */
        }
        
        .vm-list-container .vm-card .btn-group-sm .btn {
            padding: 0.25rem 0.5rem; /* 缩小按钮 */
            font-size: 0.8rem;
        }
        
        /* 空状态和加载状态的样式 */
        .vm-list-container #noVmsMessage,
        .vm-list-container #loadingMessage {
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        /* 启动失败虚拟机样式 */
        .vm-card.border-danger {
            border-width: 2px !important;
            box-shadow: 0 0 10px rgba(220, 53, 69, 0.3);
        }
        
        .vm-card.border-danger .card-header {
            background-color: rgba(220, 53, 69, 0.1);
        }
        
        .vm-card.border-danger:hover {
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.5);
        }
        
        /* 启动失败图标动画 */
        .fa-times-circle {
            animation: pulse-red 2s infinite;
        }
        
        @keyframes pulse-red {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* 异常状态虚拟机样式 */
        .vm-card.border-warning {
            border-width: 2px !important;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }
        
        .vm-card.border-warning .card-header {
            background-color: rgba(255, 193, 7, 0.1);
        }
        
        .vm-card.border-warning:hover {
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
        }
        
        /* 异常状态图标动画 */
        .fa-exclamation-triangle {
            animation: pulse-warning 2s infinite;
        }
        
        @keyframes pulse-warning {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* 小尺寸警告框 */
        .alert-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }

        /* 日志终端样式 */
        .log-line {
            margin: 0;
            padding: 1px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .log-line.debug {
            color: #6c757d;
        }

        .log-line.info {
            color: #17a2b8;
        }

        .log-line.warning {
            color: #ffc107;
        }

        .log-line.error {
            color: #dc3545;
        }

        .log-line.critical {
            color: #dc3545;
            font-weight: bold;
        }
        
        .log-line .text-primary {
            color: #007bff !important;
        }
        
        .log-line .text-info {
            color: #17a2b8 !important;
        }
        
        .log-line .text-warning {
            color: #ffc107 !important;
        }
        
        .log-line .text-danger {
            color: #dc3545 !important;
        }
        
        .log-line .text-muted {
            color: #6c757d !important;
        }
        
        .log-line .fw-bold {
            font-weight: bold !important;
        }

        #logsTerminal {
            background-color: #1e1e1e !important;
            border: none;
            outline: none;
        }

        #logsTerminal::-webkit-scrollbar {
            width: 8px;
        }

        #logsTerminal::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        #logsTerminal::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        #logsTerminal::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <div class="container-fluid d-flex flex-column">
        <!-- 头部 -->
        <div class="row bg-primary text-white p-3 flex-shrink-0">
            <div class="col">
                <h3><i class="fas fa-server me-2"></i>VirtualBox虚拟机监控系统</h3>
                <p class="mb-0">实时监控和管理VirtualBox虚拟机</p>
            </div>
            <div class="col-auto">
                <div class="d-flex align-items-center">
                    <span class="me-3">
                        <i class="fas fa-user me-1"></i>
                        欢迎，{{ session.get('username', 'admin') }}
                    </span>
                    <button class="btn btn-outline-light btn-sm" onclick="logout()">
                        <i class="fas fa-sign-out-alt me-1"></i>退出
                    </button>
                </div>
            </div>
        </div>

        <!-- 控制面板 -->
        <div class="row mt-3 flex-shrink-0">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-cogs me-2"></i>监控控制</h5>
                        <div>
                            <button id="viewLogsBtn" class="btn btn-outline-info btn-sm">
                                <i class="fas fa-terminal me-1"></i>查看日志
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="d-flex align-items-center mb-3">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="autoRefreshToggle">
                                        <label class="form-check-label" for="autoRefreshToggle">
                                            自动刷新
                                        </label>
                                    </div>
                                    <select id="autoRefreshInterval" class="form-select form-select-sm" style="width: 120px;">
                                        <option value="30" selected>30秒</option>
                                        <option value="60">1分钟</option>
                                        <option value="300">5分钟</option>
                                        <option value="600">10分钟</option>
                                    </select>
                                </div>

                                <div class="d-flex align-items-center mb-3">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="monitoringToggle">
                                        <label class="form-check-label" for="monitoringToggle">
                                            自动监控
                                        </label>
                                    </div>
                                    <select id="monitorInterval" class="form-select form-select-sm" style="width: 120px;">
                                        <option value="30" selected>30秒</option>
                                        <option value="60">1分钟</option>
                                        <option value="300">5分钟</option>
                                        <option value="600">10分钟</option>
                                    </select>
                                </div>

                                <div class="d-flex align-items-center mt-2">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="autoStartToggle">
                                        <label class="form-check-label" for="autoStartToggle">
                                            自启动虚拟机
                                        </label>
                                    </div>
                                    <div class="d-flex align-items-center">
                                        <label class="form-label mb-0 me-2 small">启动数量:</label>
                                        <select id="autoStartNum" class="form-select form-select-sm" style="width: 80px;">
                                            <option value="1">1</option>
                                            <option value="2">2</option>
                                            <option value="3">3</option>
                                            <option value="4" selected>4</option>
                                            <option value="5">5</option>
                                            <option value="6">6</option>
                                            <option value="8">8</option>
                                            <option value="10">10</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="d-flex align-items-center mt-2">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="autoDeleteToggle">
                                        <label class="form-check-label" for="autoDeleteToggle">
                                            自动删除虚拟机
                                        </label>
                                    </div>
                                    <div class="d-flex align-items-center">
                                        <label class="form-label mb-0 me-2 small">启动次数:</label>
                                        <select id="autoDeleteCount" class="form-select form-select-sm" style="width: 80px;">
                                            <option value="5">5次</option>
                                            <option value="10" selected>10次</option>
                                            <option value="15">15次</option>
                                            <option value="20">20次</option>
                                            <option value="30">30次</option>
                                            <option value="50">50次</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="alert alert-info mb-0">
                                    <small>
                                        <i class="fas fa-info-circle me-1"></i>
                                        <strong>监控状态:</strong> <span id="monitorStatus">未启动</span><br>
                                        <strong>监控模式:</strong> <span id="monitorMode">-</span><br>
                                        <strong>虚拟机数量:</strong> <span id="vmCount">0</span><br>
                                        <strong>最后更新:</strong> <span id="lastUpdate">-</span><br>
                                        <strong>选中目录:</strong> <span id="selectedDirectories">-</span><br>
                                        <strong>配置状态:</strong> <span id="configStatus">已同步</span><br>
                                        <strong>动态更新:</strong> <span id="dynamicUpdateStatus">运行中</span>
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-bolt me-2"></i>快速操作</h5>
                    </div>
                    <div class="card-body">
                        <button id="autoStartBtn" class="btn btn-success w-100 mb-2">
                            <i class="fas fa-play me-1"></i>启动所有已停止的虚拟机
                        </button>
                        <button id="startAllBtn" class="btn btn-primary w-100 mb-2">
                            <i class="fas fa-power-off me-1"></i>启动所有虚拟机
                        </button>
                        <button id="stopAllBtn" class="btn btn-warning w-100 mb-2">
                            <i class="fas fa-stop me-1"></i>停止所有虚拟机
                        </button>
                        <button id="clearFailuresBtn" class="btn btn-outline-danger w-100 mb-2">
                            <i class="fas fa-times-circle me-1"></i>清除失败标记
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 虚拟机列表 -->
        <div class="row mt-3 flex-grow-1 mb-3">
            <div class="col-12">
                <div class="card vm-list-card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-list me-2"></i>虚拟机列表</h5>
                    </div>
                    <div class="card-body">
                        <div class="vm-list-container" id="vmListContainer">
                            <div id="vmList" class="row">
                                <!-- 虚拟机卡片将在这里动态生成 -->
                            </div>
                            <div id="noVmsMessage" class="text-center text-muted py-5" style="display: none;">
                                <i class="fas fa-server fa-3x mb-3"></i>
                                <h5>未发现虚拟机</h5>
                                <p>请检查VirtualBox是否正确安装，或点击"扫描"按钮重新扫描</p>
                            </div>
                            <div id="loadingMessage" class="text-center py-5">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">加载中...</span>
                                </div>
                                <p class="mt-2">正在加载虚拟机信息...</p>
                            </div>
                            <!-- 滚动提示 -->
                            <div id="scrollHint" class="text-center text-muted py-2" style="display: none; font-size: 0.8rem;">
                                <i class="fas fa-chevron-down me-1"></i>向下滚动查看更多虚拟机
                            </div>
                        </div>
                        
                        <!-- 分页控件 -->
                        <div class="d-flex justify-content-between align-items-center mt-3 px-3 pb-2">
                            <div class="text-muted small">
                                显示 <span id="currentRange">0-0</span> 共 <span id="totalCount">0</span> 个虚拟机
                            </div>
                            <nav aria-label="虚拟机列表分页">
                                <ul class="pagination pagination-sm mb-0" id="pagination">
                                    <!-- 分页按钮将在这里动态生成 -->
                                </ul>
                            </nav>
                            <div class="d-flex align-items-center">
                                <label class="form-label mb-0 me-2 small">每页显示:</label>
                                <select id="pageSize" class="form-select form-select-sm" style="width: 70px;">
                                    <option value="6">6</option>
                                    <option value="12" selected>12</option>
                                    <option value="18">18</option>
                                    <option value="24">24</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 虚拟机详情模态框 -->
        <div class="modal fade" id="vmDetailModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">虚拟机详情</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div id="vmDetailContent">
                            <!-- 虚拟机详细信息将在这里显示 -->
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                    </div>
                </div>
            </div>
        </div>


    </div>



    <!-- 日志查看模态框 -->
    <div class="modal fade" id="logsModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-terminal me-2"></i>监控日志查看器
                    </h5>
                    <div class="btn-group">
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="copyLogs()" title="复制日志">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button type="button" class="btn btn-outline-danger btn-sm" onclick="clearLogs()" title="清空日志">
                            <i class="fas fa-trash"></i>
                        </button>
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-outline-info btn-sm" onclick="filterLogs('all')" title="显示所有日志">
                                全部
                            </button>
                            <button type="button" class="btn btn-outline-warning btn-sm" onclick="filterLogs('error')" title="只显示错误日志">
                                错误
                            </button>
                            <button type="button" class="btn btn-outline-info btn-sm" onclick="filterLogs('info')" title="只显示信息日志">
                                信息
                            </button>
                        </div>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                </div>
                <div class="modal-body p-0">
                    <div class="bg-secondary text-light p-2" style="font-size: 11px; border-bottom: 1px solid #495057;">
                        <span id="logsStatus">正在连接日志流...</span>
                    </div>
                    <div id="logsTerminal" class="bg-dark text-light p-3" style="height: 480px; font-family: 'Courier New', monospace; font-size: 12px; overflow-y: auto;">
                        <div class="text-success">=== 监控日志查看器已启动 ===</div>
                        <div class="text-info">正在连接日志流...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 全局变量
        let autoRefreshInterval = null;
        let monitoringInterval = null;
        let vmList = [];
        let configUpdateInterval = null; // 配置更新定时器
        let lastConfigUpdate = 0; // 上次配置更新时间
        let lastVMLoadTime = 0; // 上次虚拟机加载时间
        let apiCallThrottle = {}; // API调用节流控制
        
        // 分页相关变量
        let currentPage = 1;
        let pageSize = 12;
        let totalPages = 1;

        // 页面可见性检测
        let isPageVisible = true;
        
        document.addEventListener('visibilitychange', function() {
            isPageVisible = !document.hidden;
            console.log(`页面可见性变化: ${isPageVisible ? '可见' : '隐藏'}`);
            
            if (isPageVisible) {
                // 页面变为可见时，延迟更新数据，避免频繁调用
                console.log('页面变为可见，延迟更新数据');
                setTimeout(() => {
                    if (isPageVisible) { // 再次检查，确保页面仍然可见
                        loadVMs();
                        loadMonitorStatus();
                    }
                }, 1000); // 延迟1秒，避免频繁切换时的重复调用
            }
        });

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，开始初始化...');
            
            // 精确计算虚拟机列表容器高度
            calculatePreciseContainerHeight();
            
            // 确保滚动到底部时内容完全可见
            ensureBottomContentVisible();
            
            // 确保分页控件在100%比例下可见
            ensurePaginationVisible();
            
            loadVMs();
            loadMonitorStatus();
            loadVboxDirConfig();
            loadAutoMonitorConfig();
            loadAutoDeleteConfig();
            loadWebRefreshConfig();
            setupEventListeners();
            
            // 启动动态配置更新
            startDynamicConfigUpdate();
            
            // 延迟2秒后进行第一次配置检查，确保配置同步
            setTimeout(async () => {
                console.log('执行首次配置检查...');
                await checkAndUpdateConfigs();
                console.log('首次配置检查完成');
            }, 2000);
        });
        

        
        // 窗口大小改变时重新调整高度
        window.addEventListener('resize', function() {
            calculatePreciseContainerHeight();
            // 延迟执行，确保DOM更新完成
            setTimeout(() => {
                ensurePaginationVisible();
            }, 100);
        });

        // 设置事件监听器
        function setupEventListeners() {
            // 每页显示数量改变
            document.getElementById('pageSize').addEventListener('change', function() {
                pageSize = parseInt(this.value);
                currentPage = 1; // 重置到第一页
                displayVMs(vmList); // 重新显示
                console.log(`每页显示数量已更改为: ${pageSize}`);
            });

            // 自动刷新开关
            document.getElementById('autoRefreshToggle').addEventListener('change', function() {
                const enabled = this.checked;
                
                console.log(`自动刷新按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 直接更新配置文件中的AUTO_REFRESH_BUTTON_ENABLED
                updateConfigParameter('AUTO_REFRESH_BUTTON_ENABLED', enabled).then(() => {
                    // 配置更新成功后，立即通知后台重新加载配置
                    console.log('自动刷新按钮状态已更新，立即通知后台重新加载配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在通知后台');
                    
                    // 通知后台重新加载配置
                    fetch('/api/config/auto_refresh/reload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }).then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('后台自动刷新配置重新加载成功:', data.data);
                            updateConfigStatus('已同步', '后台配置已更新');
                        } else {
                            console.error('后台自动刷新配置重新加载失败:', data.message);
                            updateConfigStatus('同步失败', '后台配置更新失败');
                        }
                    }).catch(error => {
                        console.error('通知后台重新加载配置失败:', error);
                        updateConfigStatus('同步失败', '后台配置更新失败');
                    });
                    
                    if (enabled) {
                        console.log('自动刷新已启用，启动自动刷新...');
                        startAutoRefresh();
                    } else {
                        console.log('自动刷新已禁用，停止自动刷新...');
                        stopAutoRefresh();
                    }
                });
            });

            // 自动刷新间隔变化
            document.getElementById('autoRefreshInterval').addEventListener('change', function() {
                const interval = parseInt(this.value);
                const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                
                console.log(`自动刷新间隔变更: ${interval}秒`);
                
                // 直接更新配置文件中的AUTO_REFRESH_INTERVAL_VALUE
                updateConfigParameter('AUTO_REFRESH_INTERVAL_VALUE', interval).then(() => {
                    // 配置更新成功后，立即通知后台重新加载配置
                    console.log('自动刷新间隔已更新，立即通知后台重新加载配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在通知后台');
                    
                    // 通知后台重新加载配置
                    fetch('/api/config/auto_refresh/reload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }).then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('后台自动刷新配置重新加载成功:', data.data);
                            updateConfigStatus('已同步', '后台配置已更新');
                        } else {
                            console.error('后台自动刷新配置重新加载失败:', data.message);
                            updateConfigStatus('同步失败', '后台配置更新失败');
                        }
                    }).catch(error => {
                        console.error('通知后台重新加载配置失败:', error);
                        updateConfigStatus('同步失败', '后台配置更新失败');
                    });
                    
                    if (autoRefreshToggle.checked) {
                        // 如果自动刷新正在运行，立即重新启动以应用新间隔
                        console.log('自动刷新已启用，立即应用新间隔设置');
                        startAutoRefresh();
                    } else {
                        // 如果自动刷新未启用，只更新UI显示
                        console.log('自动刷新未启用，仅更新显示');
                    }
                });
            });

            // 监控开关
            document.getElementById('monitoringToggle').addEventListener('change', function() {
                const enabled = this.checked;
                const interval = document.getElementById('monitorInterval').value;
                const autoStart = document.getElementById('autoStartToggle').checked;
                
                console.log(`自动监控按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 如果监控被禁用，同时禁用自启动和自动删除功能
                if (!enabled) {
                    console.log('监控被禁用，同时禁用自启动和自动删除功能');
                    
                    // 禁用自启动虚拟机按钮
                    const autoStartToggle = document.getElementById('autoStartToggle');
                    if (autoStartToggle.checked) {
                        autoStartToggle.checked = false;
                        console.log('已禁用自启动虚拟机按钮');
                    }
                    
                    // 禁用自动删除按钮
                    const autoDeleteToggle = document.getElementById('autoDeleteToggle');
                    if (autoDeleteToggle.checked) {
                        autoDeleteToggle.checked = false;
                        console.log('已禁用自动删除按钮');
                    }
                    
                    // 保存自启动配置
                    updateConfigParameter('AUTO_START_VM_BUTTON_ENABLED', false).then(() => {
                        console.log('自启动配置已更新为禁用');
                    }).catch(error => {
                        console.error('保存自启动配置失败:', error);
                    });
                    
                    // 保存自动删除配置
                    saveAutoDeleteConfig();
                } else {
                    // 如果监控被启用，检查是否需要启用相关功能
                    const autoDeleteToggle = document.getElementById('autoDeleteToggle');
                    const autoStartToggle = document.getElementById('autoStartToggle');
                    
                    // 如果自动删除被启用，确保自启动也被启用
                    if (autoDeleteToggle.checked && !autoStartToggle.checked) {
                        console.log('自动删除已启用，自动启用自启动功能');
                        autoStartToggle.checked = true;
                        autoStartToggle.dispatchEvent(new Event('change'));
                    }
                }
                
                // 直接更新配置文件中的AUTO_MONITOR_BUTTON_ENABLED
                updateConfigParameter('AUTO_MONITOR_BUTTON_ENABLED', enabled).then(() => {
                    console.log('自动监控按钮状态已更新');
                    updateConfigStatus('同步中...', '配置已更新，正在重新加载');
                    
                    // 延迟重新加载配置以确保UI状态正确
                    setTimeout(() => {
                        loadAutoMonitorConfig();
                        updateConfigStatus('已同步', '配置重新加载完成');
                    }, 500); // 延迟500ms确保配置已写入
                }).catch(error => {
                    console.error('保存自动监控配置失败:', error);
                    // 如果保存失败，恢复按钮状态
                    this.checked = !enabled;
                    showAlert('danger', '保存自动监控配置失败');
                    updateConfigStatus('同步失败', '配置保存失败');
                });
                
                if (enabled) {
                    console.log('自动监控已启用，启动监控...');
                    startMonitoring(interval, autoStart);
                } else {
                    console.log('自动监控已禁用，停止监控...');
                    stopMonitoring();
                }
            });

            // 监控间隔变化
            document.getElementById('monitorInterval').addEventListener('change', function() {
                const interval = parseInt(this.value);
                const monitoringToggle = document.getElementById('monitoringToggle');
                
                console.log(`自动监控间隔变更: ${interval}秒`);
                
                // 直接更新配置文件中的AUTO_MONITOR_INTERVAL_VALUE
                updateConfigParameter('AUTO_MONITOR_INTERVAL_VALUE', interval).then(() => {
                    // 配置更新成功后，延迟重新加载配置以确保UI状态正确
                    console.log('自动监控间隔已更新，延迟重新加载自动监控配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在重新加载');
                    setTimeout(() => {
                        loadAutoMonitorConfig();
                        updateConfigStatus('已同步', '配置重新加载完成');
                    }, 500); // 延迟500ms确保配置已写入
                });
                
                if (monitoringToggle.checked) {
                    // 如果监控正在运行，重新启动监控以应用新设置
                    const autoStart = document.getElementById('autoStartToggle').checked;
                    console.log('自动监控已启用，立即应用新间隔设置');
                    console.log(`重新启动监控: 间隔=${interval}秒, 自动启动=${autoStart}`);
                    console.log(`监控设置: 对所有虚拟机进行监控，已关机则进行开机操作`);
                    
                    // 显示用户友好的提示
                    const modeText = autoStart ? '自动启动模式' : '状态监控模式';
                    showAlert('info', `正在重新启动监控，间隔${interval}秒，${modeText}`);
                    
                    console.log(`准备重新启动监控，参数: interval=${interval}, autoStart=${autoStart}`);
                    startMonitoring(interval, autoStart);
                    
                    // 更新监控结果检查间隔
                    updateMonitorResultsCheckInterval();
                    
                    // 延迟检查监控状态
                    setTimeout(() => {
                        console.log('延迟检查监控状态...');
                        loadMonitorStatus();
                    }, 2000);
                } else {
                    // 如果监控未启用，只更新显示，不保存配置
                    console.log('自动监控未启用，仅更新显示，不保存配置');
                }
            });

            // 自动启动开关
            document.getElementById('autoStartToggle').addEventListener('change', function() {
                const enabled = this.checked;
                const monitoringToggle = document.getElementById('monitoringToggle');
                
                console.log(`自启动虚拟机按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 检查监控状态，如果监控未启用，不允许启用自启动
                if (enabled && !monitoringToggle.checked) {
                    console.log('监控未启用，不允许启用自启动功能');
                    this.checked = false;
                    showAlert('warning', '请先启用自动监控功能');
                    return;
                }
                
                // 直接更新配置文件中的AUTO_START_VM_BUTTON_ENABLED
                updateConfigParameter('AUTO_START_VM_BUTTON_ENABLED', enabled).then(() => {
                    // 配置更新成功后，延迟重新加载配置以确保UI状态正确
                    console.log('自启动虚拟机按钮状态已更新，延迟重新加载自动监控配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在重新加载');
                    setTimeout(() => {
                        loadAutoMonitorConfig();
                        updateConfigStatus('已同步', '配置重新加载完成');
                    }, 500); // 延迟500ms确保配置已写入
                });
                
                if (monitoringToggle.checked) {
                    // 如果监控正在运行，重新启动监控以应用新设置
                    const interval = document.getElementById('monitorInterval').value;
                    const autoStart = enabled;
                    console.log('自动监控已启用，立即应用新设置');
                    console.log(`重新启动监控: 间隔=${interval}秒, 自动启动=${autoStart}`);
                    console.log(`准备重新启动监控，参数: interval=${interval}, autoStart=${autoStart}`);
                    startMonitoring(interval, autoStart);
                    
                    // 更新监控结果检查间隔
                    updateMonitorResultsCheckInterval();
                    
                    // 延迟检查监控状态
                    setTimeout(() => {
                        console.log('延迟检查监控状态...');
                        loadMonitorStatus();
                    }, 2000);
                } else {
                    // 如果监控未启用，只更新显示，不保存配置
                    console.log('自动监控未启用，仅更新显示，不保存配置');
                }
            });

            // 自启动数量下拉选择器
            document.getElementById('autoStartNum').addEventListener('change', function() {
                const num = parseInt(this.value);
                console.log(`自启动数量变更: ${num}`);
                
                // 更新配置文件中的AUTO_START_STOPPED_NUM
                updateConfigParameter('AUTO_START_STOPPED_NUM', num).then(() => {
                    console.log('自启动数量已更新到配置文件');
                    updateConfigStatus('同步中...', '自启动数量已更新');
                    
                    // 如果监控正在运行，重新启动监控以应用新设置
                    const monitoringToggle = document.getElementById('monitoringToggle');
                    if (monitoringToggle.checked) {
                        console.log('监控正在运行，重新启动以应用新的自启动数量设置');
                        const interval = document.getElementById('monitorInterval').value;
                        const autoStart = document.getElementById('autoStartToggle').checked;
                        
                        // 显示用户友好的提示
                        const actionText = num > 0 ? `启动数量设置为 ${num}` : `停止所有虚拟机`;
                        showAlert('info', `正在重新启动监控，应用新的设置: ${actionText}`);
                        
                        startMonitoring(interval, autoStart);
                        
                        // 延迟检查监控状态
                        setTimeout(() => {
                            console.log('延迟检查监控状态...');
                            loadMonitorStatus();
                        }, 2000);
                    }
                    
                    setTimeout(() => {
                        updateConfigStatus('已同步', '配置更新完成');
                    }, 500);
                }).catch(error => {
                    console.error('更新自启动数量失败:', error);
                    updateConfigStatus('同步失败', '自启动数量更新失败');
                });
            });

            // 自动删除开关
            document.getElementById('autoDeleteToggle').addEventListener('change', function() {
                const enabled = this.checked;
                const monitoringToggle = document.getElementById('monitoringToggle');
                const autoStartToggle = document.getElementById('autoStartToggle');
                
                console.log(`自动删除虚拟机按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 如果启用自动删除，检查依赖条件
                if (enabled) {
                    // 检查自动监控状态
                    if (!monitoringToggle.checked) {
                        console.log('启用自动删除时，自动监控必须启用');
                        showAlert('danger', '无法勾选自动删除虚拟机，请先启用自动监控功能');
                        // 取消勾选
                        this.checked = false;
                        return;
                    }
                    
                    // 检查自启动虚拟机状态
                    if (!autoStartToggle.checked) {
                        console.log('启用自动删除时，建议启用自启动虚拟机');
                        showAlert('warning', '建议同时启用自启动虚拟机功能以确保自动删除正常工作');
                    }
                }
                
                // 保存自动删除配置
                saveAutoDeleteConfig();
            });

            // 自动删除次数下拉选择器
            document.getElementById('autoDeleteCount').addEventListener('change', function() {
                const count = parseInt(this.value);
                console.log(`自动删除次数变更: ${count}`);
                
                // 保存自动删除配置
                saveAutoDeleteConfig();
            });

            // 日志查看按钮
            document.getElementById('viewLogsBtn').addEventListener('click', function() {
                showLogsModal();
            });

            // 快速操作按钮
            document.getElementById('autoStartBtn').addEventListener('click', function() {
                this.disabled = true;
                this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>执行中...';
                
                fetch('/api/auto_start')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showAlert('success', data.message);
                            loadVMs();
                        } else {
                            showAlert('danger', data.message);
                        }
                    })
                    .catch(error => {
                        showAlert('danger', '自动启动失败: ' + error.message);
                    })
                    .finally(() => {
                        this.disabled = false;
                        this.innerHTML = '<i class="fas fa-play me-1"></i>启动所有已停止的虚拟机';
                    });
            });

            document.getElementById('startAllBtn').addEventListener('click', function() {
                if (confirm('确定要启动所有虚拟机吗？')) {
                    startAllVMs();
                }
            });

            document.getElementById('stopAllBtn').addEventListener('click', function() {
                if (confirm('确定要停止所有虚拟机吗？')) {
                    stopAllVMs();
                }
            });

            document.getElementById('clearFailuresBtn').addEventListener('click', function() {
                if (confirm('确定要清除所有启动失败标记吗？')) {
                    clearAllStartFailures();
                }
            });


        }

        // 智能API调用节流函数
        function shouldThrottleAPI(apiName, minInterval = 5000) {
            const now = Date.now();
            const lastCall = apiCallThrottle[apiName] || 0;
            
            if (now - lastCall < minInterval) {
                console.log(`API调用过于频繁，跳过 ${apiName} 调用 (间隔: ${now - lastCall}ms, 最小间隔: ${minInterval}ms)`);
                return true;
            }
            
            apiCallThrottle[apiName] = now;
            console.log(`API调用 ${apiName} 已记录，时间: ${new Date().toLocaleTimeString()}`);
            return false;
        }

        // 加载虚拟机列表（只获取文件名）
        async function loadVMs() {
            // 从配置文件获取自动刷新间隔，作为节流时间
            const autoRefreshIntervalElement = document.getElementById('autoRefreshInterval');
            const refreshInterval = parseInt(autoRefreshIntervalElement.value) || 60;
            const throttleTime = Math.max(refreshInterval * 1000, 30000); // 最小30秒
            
            // 检查是否需要节流
            if (shouldThrottleAPI('loadVMs', throttleTime)) {
                return;
            }
            
            console.log('开始加载虚拟机列表（仅文件名）...');
            try {
                // 首先尝试新的API端点
                console.log('尝试发送请求到 /api/vms/names');
                let response = await fetch('/api/vms/names');
                console.log('收到响应:', response.status, response.statusText);
                
                // 如果新API不存在，回退到原来的API
                if (response.status === 404) {
                    console.log('新API端点不存在，回退到原来的API');
                    response = await fetch('/api/vms');
                }
                
                // 检查响应状态
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // 检查响应内容类型
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('服务器返回非JSON内容:', text.substring(0, 200));
                    throw new Error('服务器返回非JSON格式数据');
                }
                
                const data = await response.json();
                console.log('解析响应数据:', data);
                
                if (data.success) {
                    // 如果使用原来的API，直接使用返回的数据
                    if (response.url.includes('/api/vms') && !response.url.includes('/names')) {
                        vmList = data.data;
                        console.log(`获取到 ${vmList.length} 个虚拟机:`, vmList);
                        
                        // 添加启动失败标记
                        addStartFailureMarkers(vmList);
                        
                        displayVMs(vmList);
                        updateLastUpdate(data.timestamp);
                        updateVMCount(vmList.length);
                        lastVMLoadTime = Date.now();
                    } else {
                        // 使用新的API，初始化虚拟机列表
                        vmList = data.data.map(name => ({
                            name: name,
                            status: 'loading', // 初始状态为加载中
                            uuid: '...',
                            last_check: new Date().toISOString()
                        }));
                        
                        console.log(`获取到 ${vmList.length} 个虚拟机文件名:`, vmList);
                        
                        // 立即显示虚拟机列表（仅文件名）
                        displayVMs(vmList);
                        updateLastUpdate(data.timestamp);
                        updateVMCount(vmList.length);
                        lastVMLoadTime = Date.now();
                        
                        // 异步获取虚拟机状态
                        loadVMStatusesAsync();
                    }
                } else {
                    console.error('API返回错误:', data.message);
                    showAlert('danger', data.message);
                    displayVMs([]);
                }
            } catch (error) {
                console.error('加载虚拟机列表失败:', error);
                showAlert('danger', '加载虚拟机列表失败: ' + error.message);
                displayVMs([]);
            }
        }

        // 显示虚拟机列表
        function displayVMs(vms) {
            const vmListContainer = document.getElementById('vmList');
            const noVmsMessage = document.getElementById('noVmsMessage');
            const loadingMessage = document.getElementById('loadingMessage');

            // 隐藏加载消息
            loadingMessage.style.display = 'none';

            if (vms.length === 0) {
                vmListContainer.innerHTML = '';
                noVmsMessage.style.display = 'block';
                updatePagination(0, 0, 0);
                return;
            }

            noVmsMessage.style.display = 'none';
            
            // 计算分页
            totalPages = Math.ceil(vms.length / pageSize);
            currentPage = Math.min(currentPage, totalPages);
            if (currentPage < 1) currentPage = 1;
            
            // 获取当前页的数据
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, vms.length);
            const currentPageVMs = vms.slice(startIndex, endIndex);
            
            // 显示当前页的虚拟机
            vmListContainer.innerHTML = currentPageVMs.map(vm => createVMCard(vm)).join('');
            
            // 更新分页控件
            updatePagination(startIndex + 1, endIndex, vms.length);
            
            // 检查是否需要显示滚动提示
            setTimeout(() => {
                checkScrollHint();
                // 精确计算容器高度以适应新的内容
                calculatePreciseContainerHeight();
                // 确保滚动到底部时内容完全可见
                ensureBottomContentVisible();
                // 确保分页控件在100%比例下可见
                ensurePaginationVisible();
                console.log(`虚拟机列表更新完成，共 ${vms.length} 个虚拟机，当前页 ${currentPage}/${totalPages}`);
            }, 100);
        }
        
        // 检查滚动提示
        function checkScrollHint() {
            const container = document.getElementById('vmListContainer');
            const scrollHint = document.getElementById('scrollHint');
            
            if (container && scrollHint) {
                const hasScrollbar = container.scrollHeight > container.clientHeight;
                const vmCount = document.querySelectorAll('.vm-card').length;
                
                console.log(`滚动检查: 容器高度=${container.clientHeight}px, 内容高度=${container.scrollHeight}px, 虚拟机数量=${vmCount}`);
                
                if (hasScrollbar) {
                    scrollHint.style.display = 'block';
                    console.log('检测到滚动条，显示滚动提示');
                } else {
                    scrollHint.style.display = 'none';
                    console.log('无滚动条，隐藏滚动提示');
                }
            }
        }
        
        // 更新分页控件
        function updatePagination(start, end, total) {
            const currentRange = document.getElementById('currentRange');
            const totalCount = document.getElementById('totalCount');
            const pagination = document.getElementById('pagination');
            
            // 更新显示范围
            currentRange.textContent = `${start}-${end}`;
            totalCount.textContent = total;
            
            // 生成分页按钮
            let paginationHTML = '';
            
            if (totalPages <= 1) {
                paginationHTML = '<li class="page-item disabled"><span class="page-link">无分页</span></li>';
            } else {
                // 上一页按钮
                paginationHTML += `
                    <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                        <a class="page-link" href="#" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'tabindex="-1"' : ''}>
                            <i class="fas fa-chevron-left"></i>
                        </a>
                    </li>
                `;
                
                // 页码按钮
                const maxVisiblePages = 5;
                let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
                let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                
                if (endPage - startPage + 1 < maxVisiblePages) {
                    startPage = Math.max(1, endPage - maxVisiblePages + 1);
                }
                
                // 第一页
                if (startPage > 1) {
                    paginationHTML += `
                        <li class="page-item">
                            <a class="page-link" href="#" onclick="changePage(1)">1</a>
                        </li>
                    `;
                    if (startPage > 2) {
                        paginationHTML += '<li class="page-item disabled"><span class="page-link">...</span></li>';
                    }
                }
                
                // 页码
                for (let i = startPage; i <= endPage; i++) {
                    paginationHTML += `
                        <li class="page-item ${i === currentPage ? 'active' : ''}">
                            <a class="page-link" href="#" onclick="changePage(${i})">${i}</a>
                        </li>
                    `;
                }
                
                // 最后一页
                if (endPage < totalPages) {
                    if (endPage < totalPages - 1) {
                        paginationHTML += '<li class="page-item disabled"><span class="page-link">...</span></li>';
                    }
                    paginationHTML += `
                        <li class="page-item">
                            <a class="page-link" href="#" onclick="changePage(${totalPages})">${totalPages}</a>
                        </li>
                    `;
                }
                
                // 下一页按钮
                paginationHTML += `
                    <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                        <a class="page-link" href="#" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'tabindex="-1"' : ''}>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </li>
                `;
            }
            
            pagination.innerHTML = paginationHTML;
        }
        
        // 切换页面
        function changePage(page) {
            if (page < 1 || page > totalPages || page === currentPage) {
                return;
            }
            
            currentPage = page;
            displayVMs(vmList); // 重新显示当前页
        }
        
        // 异步获取虚拟机状态
        async function loadVMStatusesAsync() {
            console.log('开始异步获取虚拟机状态...');
            
            try {
                // 尝试新的状态API端点
                let response = await fetch('/api/vms/statuses');
                
                // 如果新API不存在，跳过状态更新
                if (response.status === 404) {
                    console.log('状态API端点不存在，跳过异步状态更新');
                    return;
                }
                
                // 检查响应状态
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // 检查响应内容类型
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('服务器返回非JSON内容:', text.substring(0, 200));
                    throw new Error('服务器返回非JSON格式数据');
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // 更新虚拟机状态
                    data.data.forEach(vmStatus => {
                        const vm = vmList.find(v => v.name === vmStatus.name);
                        if (vm) {
                            vm.status = vmStatus.status;
                            vm.uuid = vmStatus.uuid || vm.uuid;
                            vm.last_check = vmStatus.last_check || vm.last_check;
                            vm.start_failure = vmStatus.start_failure || false;
                            vm.exception = vmStatus.exception || false;
                        }
                    });
                    
                    // 添加启动失败标记
                    addStartFailureMarkers(vmList);
                    
                    // 重新显示当前页以更新状态
                    displayVMs(vmList);
                    
                    console.log('虚拟机状态异步更新完成');
                } else {
                    console.error('获取虚拟机状态失败:', data.message);
                }
            } catch (error) {
                console.error('异步获取虚拟机状态失败:', error);
            }
        }
        
        // 更新单个虚拟机状态
        async function updateSingleVMStatus(vmName) {
            console.log(`更新单个虚拟机状态: ${vmName}`);
            
            try {
                // 尝试新的状态API端点
                let response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/status`);
                
                // 如果新API不存在，跳过状态更新
                if (response.status === 404) {
                    console.log(`虚拟机 ${vmName} 状态API端点不存在，跳过状态更新`);
                    return;
                }
                
                // 检查响应状态
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // 检查响应内容类型
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('服务器返回非JSON内容:', text.substring(0, 200));
                    throw new Error('服务器返回非JSON格式数据');
                }
                
                const data = await response.json();
                
                if (data.success) {
                    const vm = vmList.find(v => v.name === vmName);
                    if (vm) {
                        vm.status = data.data.status;
                        vm.uuid = data.data.uuid || vm.uuid;
                        vm.last_check = data.data.last_check || vm.last_check;
                        vm.start_failure = data.data.start_failure || false;
                        vm.exception = data.data.exception || false;
                        
                        // 重新显示当前页以更新状态
                        displayVMs(vmList);
                        console.log(`虚拟机 ${vmName} 状态更新完成`);
                    }
                } else {
                    console.error(`获取虚拟机 ${vmName} 状态失败:`, data.message);
                }
            } catch (error) {
                console.error(`更新虚拟机 ${vmName} 状态失败:`, error);
            }
        }
        
        // 更新虚拟机操作状态（UI反馈）
        function updateVMOperationStatus(vmName, operation) {
            const vmCard = document.querySelector(`[data-vm-name="${vmName}"]`);
            if (vmCard) {
                const buttons = vmCard.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    btn.disabled = true;
                    btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i>${operation === 'starting' ? '启动中' : '停止中'}`;
                });
            }
        }
        

        

        
        // 确保滚动到底部时内容完全可见
        function ensureBottomContentVisible() {
            const container = document.getElementById('vmListContainer');
            if (container) {
                // 监听滚动事件
                container.addEventListener('scroll', function() {
                    const isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 10;
                    if (isAtBottom) {
                        // 如果滚动到底部，确保有足够的空间显示最后的内容
                        const lastCard = container.querySelector('.vm-card:last-child');
                        if (lastCard) {
                            const lastCardBottom = lastCard.offsetTop + lastCard.offsetHeight;
                            const containerBottom = container.scrollTop + container.clientHeight;
                            
                            if (lastCardBottom > containerBottom - 20) {
                                // 如果最后一个卡片被部分遮挡，自动滚动一点
                                container.scrollTop += 20;
                            }
                        }
                    }
                });
            }
        }
        
        // 确保分页控件在100%比例下可见
        function ensurePaginationVisible() {
            const container = document.querySelector('.vm-list-container');
            const paginationContainer = document.querySelector('.d-flex.justify-content-between.align-items-center.mt-3');
            
            if (container && paginationContainer) {
                // 检查分页控件是否在容器底部可见
                const containerRect = container.getBoundingClientRect();
                const paginationRect = paginationContainer.getBoundingClientRect();
                
                // 如果分页控件被遮挡，调整容器高度
                if (paginationRect.bottom > containerRect.bottom) {
                    const overflow = paginationRect.bottom - containerRect.bottom;
                    const currentMaxHeight = parseInt(container.style.maxHeight) || container.offsetHeight;
                    const newMaxHeight = Math.max(200, currentMaxHeight - overflow - 20); // 额外留出20px边距
                    
                    container.style.maxHeight = `${newMaxHeight}px`;
                    console.log(`调整容器高度确保分页控件可见: 新高度=${newMaxHeight}px`);
                }
            }
        }
        
        // 精确计算容器高度，使用动态比例基于500px基础值（确保100%比例下分页控件可见）
        function calculatePreciseContainerHeight() {
            const container = document.querySelector('.vm-list-container');
            if (container) {
                const windowHeight = window.innerHeight;
                
                // 根据窗口高度设置动态比例的基础值（确保100%比例下分页控件可见）
                let baseOffset = 500; // 默认基础偏移量
                
                if (windowHeight <= 600) {
                    baseOffset = 400; // 小屏幕减少基础偏移量
                } else if (windowHeight <= 800) {
                    baseOffset = 450; // 中等屏幕
                } else {
                    baseOffset = 500; // 大屏幕
                }
                
                const maxHeight = Math.max(200, windowHeight - baseOffset); // 确保最小高度为200px
                
                container.style.maxHeight = `${maxHeight}px`;
                container.style.height = 'auto';
                
                console.log(`动态比例计算容器高度: 窗口高度=${windowHeight}px, 基础偏移量=${baseOffset}px, 最大高度=${maxHeight}px`);
            }
        }

        // 创建虚拟机卡片
        function createVMCard(vm) {
            console.log(`创建虚拟机卡片: ${vm.name}, 状态: ${vm.status}`);
            const statusClass = getStatusClass(vm.status);
            const statusText = getStatusText(vm.status);
            const statusIcon = getStatusIcon(vm.status);
            
            // 检查是否有启动失败标记
            const hasStartFailure = vm.start_failure || false;
            const failureClass = hasStartFailure ? 'border-danger' : '';
            const failureIcon = hasStartFailure ? '<i class="fas fa-times-circle text-danger me-1" title="启动失败"></i>' : '';
            
            // 检查是否有异常状态
            const hasException = vm.exception || false;
            const exceptionClass = hasException ? 'border-warning' : '';
            const exceptionIcon = hasException ? '<i class="fas fa-exclamation-triangle text-warning me-1" title="虚拟机操作异常"></i>' : '';
            
            return `
                <div class="col-md-6 col-lg-4 mb-3">
                    <div class="card vm-card h-100 ${failureClass} ${exceptionClass}" data-vm-name="${vm.name}">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h6 class="mb-0 text-truncate" title="${vm.name}">
                                ${failureIcon}${exceptionIcon}<i class="fas fa-server me-1"></i>${vm.name}
                            </h6>
                            <span class="badge ${statusClass} status-badge">
                                ${statusIcon} ${statusText}
                            </span>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-8">
                                    <small class="text-muted">
                                        <i class="fas fa-fingerprint me-1"></i>UUID: ${vm.uuid.substring(0, 8)}...
                                    </small><br>
                                    <small class="text-muted">
                                        <i class="fas fa-clock me-1"></i>最后检查: ${formatTime(vm.last_check)}
                                    </small><br>
                                    <small class="text-info">
                                        <i class="fas fa-play me-1"></i>启动次数: ${vm.start_count || 0}
                                    </small>
                                    <small class="text-warning">
                                        <i class="fas fa-trash me-1"></i>删除阈值: ${vm.delete_threshold || 10}
                                    </small>
                                    ${hasStartFailure ? `<br><small class="text-danger"><i class="fas fa-exclamation-triangle me-1"></i>启动失败 (${vm.failure_count || 1}次)</small>` : ''}
                                    ${hasException ? `<br><small class="text-warning"><i class="fas fa-exclamation-triangle me-1"></i>操作异常 (${vm.exception_count || 1}次)</small>` : ''}
                                </div>
                                <div class="col-4 text-end">
                                    <div class="btn-group-vertical btn-group-sm">
                                        ${vm.status === 'poweroff' || vm.status === 'aborted' ? 
                                            `<button class="btn btn-success btn-sm" onclick="startVM('${vm.name}')" title="启动">
                                                <i class="fas fa-play"></i>
                                            </button>` : 
                                            `<button class="btn btn-warning btn-sm" onclick="stopVM('${vm.name}')" title="停止">
                                                <i class="fas fa-stop"></i>
                                            </button>`
                                        }
                                        <button class="btn btn-info btn-sm" onclick="showVMDetail('${vm.name}')" title="详情">
                                            <i class="fas fa-info-circle"></i>
                                        </button>
                                        ${hasException ? `
                                        <button class="btn btn-outline-warning btn-sm" onclick="clearVMException('${vm.name}')" title="清除操作异常标记">
                                            <i class="fas fa-times"></i>
                                        </button>
                                        ` : ''}
                                        <button class="btn btn-outline-secondary btn-sm" onclick="resetVMStartCount('${vm.name}')" title="重置启动次数">
                                            <i class="fas fa-redo"></i>
                                        </button>
                                        <button class="btn btn-outline-danger btn-sm" onclick="deleteVM('${vm.name}')" title="删除虚拟机">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            `;
        }

        // 获取状态样式类
        function getStatusClass(status) {
            console.log(`获取状态样式类，原始状态: ${status}`);
            switch (status) {
                case 'running': return 'bg-success';
                case 'poweroff': return 'bg-secondary';
                case 'paused': return 'bg-warning';
                case 'saved': return 'bg-info';
                case 'aborted': return 'bg-danger';
                case 'unknown': return 'bg-dark';
                default: 
                    console.warn(`未知状态值: ${status}`);
                    return 'bg-dark';
            }
        }

        // 获取状态文本
        function getStatusText(status) {
            console.log(`获取状态文本，原始状态: ${status}`);
            switch (status) {
                case 'running': return '运行中';
                case 'poweroff': return '已关闭';
                case 'paused': return '已暂停';
                case 'saved': return '已保存';
                case 'aborted': return '异常终止';
                case 'loading': return '加载中...';
                case 'unknown': return '未知状态';
                default: 
                    console.warn(`未知状态值: ${status}`);
                    return '未知状态';
            }
        }

        // 获取状态图标
        function getStatusIcon(status) {
            console.log(`获取状态图标，原始状态: ${status}`);
            switch (status) {
                case 'running': return '<i class="fas fa-play"></i>';
                case 'poweroff': return '<i class="fas fa-stop"></i>';
                case 'paused': return '<i class="fas fa-pause"></i>';
                case 'saved': return '<i class="fas fa-save"></i>';
                case 'aborted': return '<i class="fas fa-exclamation-triangle"></i>';
                case 'loading': return '<i class="fas fa-spinner fa-spin"></i>';
                case 'unknown': return '<i class="fas fa-question"></i>';
                default: 
                    console.warn(`未知状态值: ${status}`);
                    return '<i class="fas fa-question"></i>';
            }
        }

        // 格式化时间
        function formatTime(timestamp) {
            if (!timestamp) return '-';
            const date = new Date(timestamp);
            return date.toLocaleString('zh-CN');
        }

        // 启动虚拟机（异步操作）
        async function startVM(vmName) {
            if (!confirm(`确定要启动虚拟机 "${vmName}" 吗？`)) {
                return;
            }

            console.log(`开始启动虚拟机: ${vmName}`);
            
            // 立即更新UI状态为操作中
            updateVMOperationStatus(vmName, 'starting');
            
            try {
                const url = `/api/vm/${encodeURIComponent(vmName)}/start`;
                console.log('发送请求到:', url);
                const response = await fetch(url);
                console.log('收到响应:', response.status, response.statusText);
                
                const data = await response.json();
                console.log('解析响应数据:', data);
                
                if (data.success) {
                    console.log(`虚拟机 ${vmName} 启动成功`);
                    showAlert('success', data.message);
                    // 清除启动失败标记
                    clearStartFailure(vmName);
                    // 清除后端失败标记
                    clearBackendStartFailure(vmName);
                    // 清除异常状态
                    await clearVMExceptionBackend(vmName);
                    // 异步更新单个虚拟机状态
                    await updateSingleVMStatus(vmName);
                } else {
                    console.error(`虚拟机 ${vmName} 启动失败:`, data.message);
                    showAlert('danger', data.message);
                    // 标记启动失败
                    markStartFailure(vmName);
                    // 异步更新单个虚拟机状态
                    await updateSingleVMStatus(vmName);
                }
            } catch (error) {
                console.error(`启动虚拟机 ${vmName} 失败:`, error);
                showAlert('danger', '启动虚拟机失败: ' + error.message);
                // 标记启动失败
                markStartFailure(vmName);
                // 异步更新单个虚拟机状态
                await updateSingleVMStatus(vmName);
            }
        }

        // 停止虚拟机（异步操作）
        async function stopVM(vmName) {
            if (!confirm(`确定要停止虚拟机 "${vmName}" 吗？`)) {
                return;
            }

            console.log(`开始停止虚拟机: ${vmName}`);
            
            // 立即更新UI状态为操作中
            updateVMOperationStatus(vmName, 'stopping');
            
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/stop`);
                const data = await response.json();
                
                if (data.success) {
                    showAlert('success', data.message);
                    // 清除异常状态
                    await clearVMExceptionBackend(vmName);
                    // 异步更新单个虚拟机状态
                    await updateSingleVMStatus(vmName);
                } else {
                    showAlert('danger', data.message);
                    // 异步更新单个虚拟机状态
                    await updateSingleVMStatus(vmName);
                }
            } catch (error) {
                showAlert('danger', '停止虚拟机失败: ' + error.message);
                // 异步更新单个虚拟机状态
                await updateSingleVMStatus(vmName);
            }
        }









        // 显示虚拟机详情（异步操作）
        async function showVMDetail(vmName) {
            console.log(`开始获取虚拟机详情: ${vmName}`);
            
            // 显示加载状态
            const modal = new bootstrap.Modal(document.getElementById('vmDetailModal'));
            const content = document.getElementById('vmDetailContent');
            content.innerHTML = `
                <div class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">加载中...</span>
                    </div>
                    <p class="mt-2">正在获取虚拟机详情...</p>
                </div>
            `;
            modal.show();
            
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/info`);
                const data = await response.json();
                
                if (data.success) {
                    content.innerHTML = createVMDetailHTML(vmName, data.data);
                } else {
                    content.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                }
            } catch (error) {
                console.error(`获取虚拟机详情失败: ${vmName}`, error);
                content.innerHTML = `<div class="alert alert-danger">获取虚拟机详情失败: ${error.message}</div>`;
            }
        }

        // 创建虚拟机详情HTML
        function createVMDetailHTML(vmName, info) {
            let html = `<h6>虚拟机: ${vmName}</h6><hr>`;
            
            for (const [key, value] of Object.entries(info)) {
                html += `<div class="row mb-2">
                    <div class="col-4"><strong>${key}:</strong></div>
                    <div class="col-8">${value}</div>
                </div>`;
            }
            
            return html;
        }

        // 启动所有虚拟机
        async function startAllVMs() {
            const stoppedVMs = vmList.filter(vm => vm.status === 'poweroff' || vm.status === 'aborted');
            
            if (stoppedVMs.length === 0) {
                showAlert('info', '没有需要启动的虚拟机');
                return;
            }

            let successCount = 0;
            for (const vm of stoppedVMs) {
                try {
                    const response = await fetch(`/api/vm/${encodeURIComponent(vm.name)}/start`);
                    const data = await response.json();
                    if (data.success) {
                        successCount++;
                    }
                } catch (error) {
                    console.error(`启动虚拟机 ${vm.name} 失败:`, error);
                }
            }

            showAlert('success', `批量启动完成，成功启动 ${successCount}/${stoppedVMs.length} 个虚拟机`);
            // 延迟加载虚拟机列表，避免频繁调用
            setTimeout(() => {
                if (isPageVisible) {
                    loadVMs();
                }
            }, 2000); // 延迟2秒，等待虚拟机状态稳定
        }

        // 停止所有虚拟机
        async function stopAllVMs() {
            const runningVMs = vmList.filter(vm => vm.status === 'running');
            
            if (runningVMs.length === 0) {
                showAlert('info', '没有正在运行的虚拟机');
                return;
            }

            let successCount = 0;
            for (const vm of runningVMs) {
                try {
                    const response = await fetch(`/api/vm/${encodeURIComponent(vm.name)}/stop`);
                    const data = await response.json();
                    if (data.success) {
                        successCount++;
                    }
                } catch (error) {
                    console.error(`停止虚拟机 ${vm.name} 失败:`, error);
                }
            }

            showAlert('success', `批量停止完成，成功停止 ${successCount}/${runningVMs.length} 个虚拟机`);
            // 延迟加载虚拟机列表，避免频繁调用
            setTimeout(() => {
                if (isPageVisible) {
                    loadVMs();
                }
            }, 2000); // 延迟2秒，等待虚拟机状态稳定
        }

        // 自动刷新控制
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            // 从配置文件获取间隔时间，确保与前台设置一致
            const autoRefreshIntervalElement = document.getElementById('autoRefreshInterval');
            const interval = parseInt(autoRefreshIntervalElement.value) * 1000; // 转换为毫秒
            
            // 避免过短的刷新间隔，最小30秒
            const minInterval = 30000; // 30秒
            const actualInterval = Math.max(interval, minInterval);
            
            console.log(`自动刷新配置: 前台设置=${interval/1000}秒, 实际间隔=${actualInterval/1000}秒`);
            
            autoRefreshInterval = setInterval(() => {
                // 只在页面可见时执行自动刷新
                if (isPageVisible) {
                    console.log(`[${new Date().toLocaleTimeString()}] 执行自动刷新 (间隔: ${actualInterval/1000}秒)...`);
                    loadVMs();
                } else {
                    console.log(`[${new Date().toLocaleTimeString()}] 页面不可见，跳过自动刷新`);
                }
            }, actualInterval);
            
            console.log(`自动刷新已启动，间隔: ${actualInterval/1000}秒`);
            
            // 避免频繁保存配置，只在必要时保存
            if (actualInterval !== interval) {
                console.log('检测到刷新间隔过短，已调整为最小30秒间隔');
            }
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            
            console.log('自动刷新已停止');
        }



        // 防止重复保存的标志
        let isSavingWebRefreshConfig = false;
        let isSavingAutoMonitorConfig = false;
        
        // 保存Web自动刷新配置
        async function saveWebRefreshConfig() {
            if (isSavingWebRefreshConfig) {
                console.log('正在保存Web自动刷新配置，跳过重复请求');
                return;
            }
            
            isSavingWebRefreshConfig = true;
            
            try {
                const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                const autoRefreshInterval = document.getElementById('autoRefreshInterval');
                
                const enabled = autoRefreshToggle.checked;
                const interval = parseInt(autoRefreshInterval.value);
                
                console.log('保存Web自动刷新配置:', { enabled, interval });
                
                // 始终保存配置，无论启用还是禁用
                const response = await fetch('/api/config/web_refresh', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        enabled: enabled,
                        interval: interval
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('Web自动刷新配置保存成功');
                    console.log('配置详情:', data.data);
                    
                    // 更新状态显示
                    if (data.data && data.data.enabled) {
                        showAlert('success', `自动刷新已启用，间隔: ${data.data.interval}秒`);
                    } else {
                        showAlert('success', '自动刷新已禁用');
                    }
                    
                    // 不重新加载配置，避免无限循环
                    console.log('配置保存成功，跳过重新加载');
                } else {
                    console.error('保存Web自动刷新配置失败:', data.message);
                    showAlert('danger', '保存Web自动刷新配置失败: ' + data.message);
                }
            } catch (error) {
                console.error('保存Web自动刷新配置失败:', error);
                showAlert('danger', '保存Web自动刷新配置失败: ' + error.message);
            } finally {
                isSavingWebRefreshConfig = false;
            }
        }

        // 监控结果检查
        let monitorResultsInterval = null;
        let currentCheckInterval = 0; // 记录当前的检查间隔

        function startMonitorResultsCheck() {
            if (monitorResultsInterval) {
                clearInterval(monitorResultsInterval);
            }
            
            // 动态获取当前监控间隔设置
            const checkInterval = getCurrentMonitorResultsCheckInterval();
            const monitorInterval = parseInt(document.getElementById('monitorInterval').value) || 30;
            
            currentCheckInterval = checkInterval; // 记录当前间隔
            
            monitorResultsInterval = setInterval(() => {
                checkMonitorResults();
            }, checkInterval * 1000);
            
            console.log(`监控结果检查已启动，间隔: ${checkInterval}秒 (基于监控间隔: ${monitorInterval}秒)`);
            console.debug(`间隔计算详情: 监控间隔=${monitorInterval}秒, 检查间隔=${checkInterval}秒`);
        }
        
        function updateMonitorResultsCheckInterval() {
            // 如果监控结果检查正在运行，重新启动以应用新间隔
            if (monitorResultsInterval) {
                console.log('更新监控结果检查间隔...');
                startMonitorResultsCheck();
            }
        }
        
        // 获取当前监控结果检查间隔
        function getCurrentMonitorResultsCheckInterval() {
            const monitorIntervalElement = document.getElementById('monitorInterval');
            const monitorInterval = parseInt(monitorIntervalElement.value) || 30;
            
            // 监控结果检查间隔与监控间隔保持一致
            return monitorInterval;
        }

        function stopMonitorResultsCheck() {
            if (monitorResultsInterval) {
                clearInterval(monitorResultsInterval);
                monitorResultsInterval = null;
            }
            console.log('监控结果检查已停止');
        }

        async function checkMonitorResults() {
            try {
                console.debug('开始检查监控结果...');
                const response = await fetch('/api/monitor/last_results');
                const data = await response.json();
                
                console.debug('监控结果响应:', data);
                
                if (data.success) {
                    const results = data.data.last_results;
                    const monitoring = data.data.monitoring;
                    const auto_start_enabled = data.data.auto_start_enabled;
                    
                    if (results && results.length > 0) {
                        const successCount = results.filter(r => r.success).length;
                        const totalCount = results.length;
                        
                        console.log(`监控结果: 总数=${totalCount}, 成功=${successCount}`);
                        console.debug('详细结果:', results);
                        
                        if (successCount > 0) {
                            console.log(`自动监控执行完成：成功启动 ${successCount}/${totalCount} 个虚拟机`);
                            showAlert('success', `自动监控执行完成：成功启动 ${successCount}/${totalCount} 个虚拟机`);
                        } else if (totalCount > 0) {
                            console.warn(`自动监控执行完成：尝试启动 ${totalCount} 个虚拟机，但都失败了`);
                            showAlert('warning', `自动监控执行完成：尝试启动 ${totalCount} 个虚拟机，但都失败了`);
                        }
                    } else if (monitoring) {
                        // 状态监控模式
                        console.log('状态监控模式：仅监控虚拟机状态，不执行自动启动');
                        console.debug('监控状态:', { monitoring, auto_start_enabled });
                    }
                    
                    // 重新加载虚拟机列表以更新状态
                    console.debug('重新加载虚拟机列表...');
                    loadVMs();
                } else {
                    console.debug('没有新的监控结果');
                }
                
                // 检查监控间隔是否发生变化，如果变化则重新设置定时器
                const newInterval = getCurrentMonitorResultsCheckInterval();
                
                if (newInterval !== currentCheckInterval) {
                    console.log(`检测到监控间隔变化，重新设置监控结果检查间隔: ${currentCheckInterval}秒 -> ${newInterval}秒`);
                    console.debug(`间隔变化详情: 当前间隔=${currentCheckInterval}秒, 新间隔=${newInterval}秒`);
                    updateMonitorResultsCheckInterval();
                }
            } catch (error) {
                console.error('检查监控结果失败:', error);
                console.debug('错误详情:', error);
            }
        }

        // 监控控制
        async function startMonitoring(interval, autoStart = true) {
            try {
                console.log(`启动监控: 间隔=${interval}秒, 自动启动=${autoStart}`);
                console.debug('监控启动参数:', { interval, autoStart });
                
                // 确保参数类型正确
                interval = parseInt(interval);
                autoStart = Boolean(autoStart);
                
                // 记录启动时间戳
                const startTime = new Date().toISOString();
                console.debug('监控启动时间:', startTime);
                
                console.debug('参数验证后:', { interval, autoStart, startTime });
                
                // 添加详细的调试信息
                console.log(`=== 监控启动调试信息 ===`);
                console.log(`间隔时间: ${interval}秒`);
                console.log(`自动启动: ${autoStart}`);
                console.log(`启动时间: ${startTime}`);
                console.log(`参数类型检查: interval=${typeof interval}, autoStart=${typeof autoStart}`);
                console.log(`监控模式: ${autoStart ? '自动启动模式' : '状态监控模式'}`);
                console.log(`执行策略: 每${interval}秒检查所有虚拟机，${autoStart ? '自动启动已关机的虚拟机' : '仅监控状态'}`);
                
                const url = `/api/monitor/start?interval=${interval}&auto_start=${autoStart ? 'true' : 'false'}&start_time=${encodeURIComponent(startTime)}`;
                console.debug('请求URL:', url);
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.debug('监控启动响应:', data);
                
                if (data.success) {
                    console.log('监控启动成功');
                    console.debug('监控状态更新');
                    
                    const startTimeText = data.start_time ? `，启动时间: ${new Date(data.start_time).toLocaleString()}` : '';
                    const modeText = autoStart ? '自动启动模式' : '状态监控模式';
                    
                    showAlert('success', `监控已启动，间隔${interval}秒，${modeText}${startTimeText}`);
                    document.getElementById('monitorStatus').textContent = '运行中';
                    document.getElementById('monitorMode').textContent = modeText;
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.add('monitoring-active');
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.remove('monitoring-inactive');
                    
                    // 启动监控结果检查
                    console.debug('启动监控结果检查');
                    startMonitorResultsCheck();
                } else {
                    console.error('监控启动失败:', data.message);
                    showAlert('danger', data.message);
                    document.getElementById('monitoringToggle').checked = false;
                }
            } catch (error) {
                console.error('启动监控失败:', error);
                console.debug('错误详情:', error);
                showAlert('danger', '启动监控失败: ' + error.message);
                document.getElementById('monitoringToggle').checked = false;
            }
        }

        async function stopMonitoring() {
            try {
                console.log('停止监控...');
                console.debug('发送停止监控请求');
                
                const response = await fetch('/api/monitor/stop');
                const data = await response.json();
                
                console.debug('停止监控响应:', data);
                
                if (data.success) {
                    console.log('监控停止成功');
                    console.debug('更新监控状态显示');
                    showAlert('success', data.message);
                    document.getElementById('monitorStatus').textContent = '已停止';
                    document.getElementById('monitorMode').textContent = '-';
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.remove('monitoring-active');
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.add('monitoring-inactive');
                    
                    // 停止监控结果检查
                    console.debug('停止监控结果检查');
                    stopMonitorResultsCheck();
                } else {
                    console.error('停止监控失败:', data.message);
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error('停止监控失败:', error);
                console.debug('错误详情:', error);
                showAlert('danger', '停止监控失败: ' + error.message);
            }
        }

        // 加载监控状态
        async function loadMonitorStatus() {
            try {
                const response = await fetch('/api/monitor/status');
                const data = await response.json();
                
                if (data.success) {
                    const status = data.data.monitoring ? '运行中' : '已停止';
                    document.getElementById('monitorStatus').textContent = status;
                    
                    const statusElement = document.getElementById('monitorStatus').parentElement.parentElement;
                    if (data.data.monitoring) {
                        statusElement.classList.add('monitoring-active');
                        statusElement.classList.remove('monitoring-inactive');
                        document.getElementById('monitoringToggle').checked = true;
                    } else {
                        statusElement.classList.remove('monitoring-active');
                        statusElement.classList.add('monitoring-inactive');
                        document.getElementById('monitoringToggle').checked = false;
                    }
                }
            } catch (error) {
                console.error('加载监控状态失败:', error);
            }
        }

        // 更新最后更新时间
        function updateLastUpdate(timestamp) {
            document.getElementById('lastUpdate').textContent = formatTime(timestamp);
        }

        // 更新虚拟机数量
        function updateVMCount(count) {
            document.getElementById('vmCount').textContent = count;
        }

        // 显示提示消息
        function showAlert(type, message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(alertDiv);
            
            // 3秒后自动消失
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 3000);
        }



        // 加载VBOX_DIR配置
        async function loadVboxDirConfig() {
            try {
                const response = await fetch('/api/config/vbox_dir');
                const data = await response.json();
                
                if (data.success) {
                    const vboxDir = data.data.vbox_dir;
                    updateSelectedDirectoriesDisplay([vboxDir]);
                    console.log('VBOX_DIR配置:', vboxDir);
                } else {
                    console.error('获取VBOX_DIR配置失败:', data.message);
                    updateSelectedDirectoriesDisplay(['配置读取失败']);
                }
            } catch (error) {
                console.error('获取VBOX_DIR配置失败:', error);
                updateSelectedDirectoriesDisplay(['配置读取失败']);
            }
        }

        // 加载自动监控配置
        async function loadAutoMonitorConfig() {
            try {
                console.log('开始加载自动监控配置...');
                const response = await fetch('/api/config/auto_monitor');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    console.log('=== 自动监控配置调试信息 ===');
                    console.log('API返回的完整配置:', config);
                    console.log('enable_auto_monitoring:', config.enable_auto_monitoring);
                    console.log('button_enabled:', config.button_enabled);
                    console.log('auto_start_button_enabled:', config.auto_start_button_enabled);
                    console.log('interval_value:', config.interval_value);
                    console.log('default_interval:', config.default_interval);
                    console.log('================================');
                    
                    // 设置默认值
                    const monitoringToggle = document.getElementById('monitoringToggle');
                    const monitorInterval = document.getElementById('monitorInterval');
                    const autoStartToggle = document.getElementById('autoStartToggle');
                    
                    // 使用新的配置结构
                    console.log('使用新的配置结构');
                    
                    // 临时禁用change事件监听器，避免触发自动保存
                    const originalMonitoringHandler = monitoringToggle.onchange;
                    const originalAutoStartHandler = autoStartToggle.onchange;
                    monitoringToggle.onchange = null;
                    autoStartToggle.onchange = null;
                    
                    // 设置自动监控按钮状态
                    const monitoringEnabled = config.button_enabled || false;
                    monitoringToggle.checked = monitoringEnabled;
                    console.log('设置自动监控按钮状态:', monitoringEnabled);
                    
                    // 设置监控间隔
                    const intervalValue = config.interval_value || 30;
                    monitorInterval.value = intervalValue;
                    console.log('设置监控间隔:', intervalValue);
                    
                    // 设置自启动虚拟机按钮状态
                    const autoStartEnabled = config.auto_start_button_enabled || false;
                    autoStartToggle.checked = autoStartEnabled;
                    console.log('设置自启动虚拟机按钮状态:', autoStartEnabled);
                    
                    // 设置自启动数量
                    const autoStartNum = document.getElementById('autoStartNum');
                    const autoStartNumValue = config.auto_start_stopped_num || 4;
                    autoStartNum.value = autoStartNumValue;
                    console.log('设置自启动数量:', autoStartNumValue);
                    
                    // 恢复change事件监听器
                    monitoringToggle.onchange = originalMonitoringHandler;
                    autoStartToggle.onchange = originalAutoStartHandler;
                    
                    // 不触发change事件，避免自动保存
                    console.log('配置加载完成，UI已更新');
                    
                    console.log('最终配置设置完成:', {
                        monitoring: monitoringToggle.checked,
                        interval: monitorInterval.value,
                        autoStart: autoStartToggle.checked
                    });
                    
                    // 如果自动监控已启用，启动监控
                    if (monitoringToggle.checked) {
                        console.log('自动监控已启用，启动监控...');
                        const interval = monitorInterval.value;
                        const autoStart = autoStartToggle.checked;
                        startMonitoring(interval, autoStart, false); // 不显示通知
                    } else {
                        console.log('自动监控未启用');
                        
                        // 如果监控未启用，确保自启动和自动删除也被禁用
                        if (autoStartToggle.checked) {
                            console.log('监控未启用，禁用自启动功能');
                            autoStartToggle.checked = false;
                        }
                        
                        // 获取自动删除按钮并禁用
                        const autoDeleteToggle = document.getElementById('autoDeleteToggle');
                        if (autoDeleteToggle && autoDeleteToggle.checked) {
                            console.log('监控未启用，禁用自动删除功能');
                            autoDeleteToggle.checked = false;
                        }
                    }
                    
                    // 检查依赖关系 - 只在加载时检查，不强制启用
                    const autoDeleteToggle = document.getElementById('autoDeleteToggle');
                    if (autoDeleteToggle && autoDeleteToggle.checked) {
                        console.log('检测到自动删除已启用，但允许用户手动控制自动监控状态');
                        // 不再强制启用自动监控，让用户自己决定
                    }
                } else {
                    console.error('获取自动监控配置失败:', data.message);
                }
            } catch (error) {
                console.error('获取自动监控配置失败:', error);
            }
        }

        // 加载自动删除配置
        async function loadAutoDeleteConfig() {
            try {
                console.log('开始加载自动删除配置...');
                const response = await fetch('/api/auto_delete/config');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.config;
                    console.log('=== 自动删除配置调试信息 ===');
                    console.log('API返回的完整配置:', config);
                    console.log('enabled:', config.enabled);
                    console.log('max_count:', config.max_count);
                    console.log('backup_dir:', config.backup_dir);
                    console.log('================================');
                    
                    // 设置默认值
                    const autoDeleteToggle = document.getElementById('autoDeleteToggle');
                    const autoDeleteCount = document.getElementById('autoDeleteCount');
                    
                    // 临时禁用change事件监听器，避免触发自动保存
                    const originalAutoDeleteHandler = autoDeleteToggle.onchange;
                    const originalAutoDeleteCountHandler = autoDeleteCount.onchange;
                    autoDeleteToggle.onchange = null;
                    autoDeleteCount.onchange = null;
                    
                    // 检查监控状态，如果监控未启用，强制禁用自动删除
                    const monitoringToggle = document.getElementById('monitoringToggle');
                    const shouldEnableAutoDelete = config.enabled && monitoringToggle.checked;
                    
                    // 设置自动删除按钮状态
                    autoDeleteToggle.checked = shouldEnableAutoDelete;
                    console.log('设置自动删除按钮状态:', shouldEnableAutoDelete);
                    
                    // 设置自动删除次数
                    const maxCount = config.max_count || 10;
                    autoDeleteCount.value = maxCount;
                    console.log('设置自动删除次数:', maxCount);
                    
                    // 恢复change事件监听器
                    autoDeleteToggle.onchange = originalAutoDeleteHandler;
                    autoDeleteCount.onchange = originalAutoDeleteCountHandler;
                    
                    console.log('自动删除配置加载完成，UI已更新');
                    
                    // 如果监控未启用但配置显示启用，更新配置文件并显示提示
                    if (config.enabled && !monitoringToggle.checked) {
                        console.log('监控未启用但自动删除配置为启用，更新配置文件');
                        showAlert('warning', '监控未启用，自动删除功能已被禁用');
                        saveAutoDeleteConfig();
                    }
                } else {
                    console.error('获取自动删除配置失败:', data.message);
                }
            } catch (error) {
                console.error('获取自动删除配置失败:', error);
            }
        }

        // 保存自动删除配置
        async function saveAutoDeleteConfig() {
            try {
                const autoDeleteToggle = document.getElementById('autoDeleteToggle');
                const autoDeleteCount = document.getElementById('autoDeleteCount');
                const monitoringToggle = document.getElementById('monitoringToggle');
                
                // 检查监控状态，如果监控未启用，强制禁用自动删除
                let enabled = autoDeleteToggle.checked;
                if (!monitoringToggle.checked) {
                    enabled = false;
                    console.log('监控未启用，强制禁用自动删除功能');
                }
                
                const maxCount = parseInt(autoDeleteCount.value);
                const backupDir = 'delete_bak';
                
                console.log('保存自动删除配置:', { enabled, maxCount, backupDir });
                
                const response = await fetch('/api/auto_delete/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        enabled: enabled,
                        max_count: maxCount,
                        backup_dir: backupDir
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('自动删除配置保存成功');
                    if (!monitoringToggle.checked && autoDeleteToggle.checked) {
                        showAlert('warning', '监控未启用，自动删除功能已被禁用');
                    } else {
                        showAlert('success', '自动删除配置已保存');
                    }
                } else {
                    console.error('保存自动删除配置失败:', data.message);
                    showAlert('danger', '保存自动删除配置失败: ' + data.message);
                }
            } catch (error) {
                console.error('保存自动删除配置失败:', error);
                showAlert('danger', '保存自动删除配置失败: ' + error.message);
            }
        }

        // 加载Web自动刷新配置
        async function loadWebRefreshConfig() {
            try {
                console.log('开始加载Web自动刷新配置...');
                const response = await fetch('/api/config/web_refresh');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    console.log('=== Web自动刷新配置调试信息 ===');
                    console.log('API返回的完整配置:', config);
                    console.log('web_auto_refresh_enabled:', config.web_auto_refresh_enabled);
                    console.log('button_enabled:', config.button_enabled);
                    console.log('interval_value:', config.interval_value);
                    console.log('default_interval:', config.default_interval);
                    console.log('==================================');
                    
                    // 设置默认值
                    const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                    const autoRefreshInterval = document.getElementById('autoRefreshInterval');
                    
                    // 使用新的配置结构
                    console.log('使用新的配置结构');
                    
                    // 临时禁用change事件监听器，避免触发自动保存
                    const originalChangeHandler = autoRefreshToggle.onchange;
                    autoRefreshToggle.onchange = null;
                    
                    // 设置自动刷新按钮状态
                    const refreshEnabled = config.button_enabled || false;
                    autoRefreshToggle.checked = refreshEnabled;
                    console.log('设置自动刷新按钮状态:', refreshEnabled);
                    
                    // 设置自动刷新间隔
                    const refreshInterval = config.interval_value || 60;
                    autoRefreshInterval.value = refreshInterval;
                    console.log('设置自动刷新间隔:', refreshInterval);
                    
                    // 恢复change事件监听器
                    autoRefreshToggle.onchange = originalChangeHandler;
                    

                    
                    // 不触发change事件，避免自动保存
                    console.log('Web自动刷新配置加载完成，UI已更新');
                    
                    // 如果自动刷新已启用，启动自动刷新
                    if (autoRefreshToggle.checked) {
                        console.log('Web自动刷新已启用，启动自动刷新...');
                        startAutoRefresh();
                    } else {
                        console.log('Web自动刷新未启用');
                    }
                } else {
                    console.error('获取Web自动刷新配置失败:', data.message);
                }
            } catch (error) {
                console.error('获取Web自动刷新配置失败:', error);
            }
        }

        // 更新单个配置参数
        async function updateConfigParameter(parameterName, value) {
            try {
                console.log(`更新配置参数: ${parameterName} = ${value}`);
                
                const response = await fetch('/api/config/update_parameter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        parameter: parameterName,
                        value: value
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log(`配置参数 ${parameterName} 更新成功`);
                    return Promise.resolve(data);
                } else {
                    console.error(`配置参数 ${parameterName} 更新失败:`, data.message);
                    showAlert('danger', `配置参数更新失败: ${data.message}`);
                    return Promise.reject(new Error(data.message));
                }
            } catch (error) {
                console.error(`更新配置参数 ${parameterName} 失败:`, error);
                showAlert('danger', `配置参数更新失败: ${error.message}`);
                return Promise.reject(error);
            }
        }

        // 保存自动监控配置
        async function saveAutoMonitorConfig() {
            if (isSavingAutoMonitorConfig) {
                console.log('正在保存自动监控配置，跳过重复请求');
                return;
            }
            
            isSavingAutoMonitorConfig = true;
            
            try {
                console.log('开始保存自动监控配置...');
                const monitoringToggle = document.getElementById('monitoringToggle');
                const monitorInterval = document.getElementById('monitorInterval');
                const autoStartToggle = document.getElementById('autoStartToggle');
                
                // 确保参数类型正确
                const enabled = Boolean(monitoringToggle.checked);
                const interval = parseInt(monitorInterval.value);
                const auto_start_enabled = Boolean(autoStartToggle.checked);
                
                console.log('准备保存的配置:', {
                    enabled: enabled,
                    interval: interval,
                    auto_start_enabled: auto_start_enabled
                });
                
                // 始终保存AUTO_MONITOR_BUTTON_ENABLED状态
                const enableResponse = await fetch('/api/config/update_parameter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        parameter: 'AUTO_MONITOR_BUTTON_ENABLED',
                        value: enabled
                    })
                });
                
                const enableData = await enableResponse.json();
                if (!enableData.success) {
                    console.error('保存AUTO_MONITOR_BUTTON_ENABLED失败:', enableData.message);
                    showAlert('danger', '保存自动监控状态失败: ' + enableData.message);
                    return;
                }
                
                // 只有在自动监控启用时才保存其他配置
                if (enabled) {
                    const config = {
                        enabled: enabled,
                        interval: interval,
                        auto_start_enabled: auto_start_enabled
                    };
                    
                    const response = await fetch('/api/config/auto_monitor', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(config)
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('自动监控配置保存成功');
                        showAlert('success', '自动监控配置已保存');
                    } else {
                        console.error('保存自动监控配置失败:', data.message);
                        showAlert('danger', '保存自动监控配置失败: ' + data.message);
                    }
                } else {
                    console.log('自动监控已禁用，ENABLE_AUTO_MONITORING已保存为False');
                    showAlert('success', '自动监控已禁用，配置已保存');
                }
            } catch (error) {
                console.error('保存自动监控配置失败:', error);
                showAlert('danger', '保存自动监控配置失败: ' + error.message);
            } finally {
                isSavingAutoMonitorConfig = false;
            }
        }



        // 加载选中的目录
        async function loadSelectedDirectories() {
            try {
                const response = await fetch('/api/config/get_directories');
                const data = await response.json();
                
                if (data.success) {
                    displaySelectedDirectories(data.data);
                } else {
                    console.error('获取选中目录失败:', data.message);
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error('加载选中目录失败:', error);
                showAlert('danger', '加载选中目录失败: ' + error.message);
            }
        }

        // 显示选中的目录
        function displaySelectedDirectories(directories) {
            const container = document.getElementById('selectedDirectoriesList');
            
            if (directories.length === 0) {
                container.innerHTML = '<p class="text-muted">暂无选中的目录</p>';
                return;
            }
            
            let html = '';
            directories.forEach((directory, index) => {
                html += `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2 border rounded">
                        <div class="flex-grow-1">
                            <div class="fw-bold">${directory}</div>
                            <small class="text-muted">虚拟机目录</small>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-info" onclick="scanDirectory('${directory}')" title="重新扫描">
                                <i class="fas fa-search"></i>
                            </button>
                            <button class="btn btn-outline-danger" onclick="removeDirectory(${index})" title="删除">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }









        // 更新选中目录显示
        function updateSelectedDirectoriesDisplay(directories) {
            const displayElement = document.getElementById('selectedDirectories');
            if (directories.length === 0) {
                displayElement.textContent = '未选择';
            } else {
                displayElement.textContent = directories.join(', ');
            }
        }



        // 启动失败标记管理
        let startFailureMap = new Map();

        // 标记启动失败
        function markStartFailure(vmName) {
            startFailureMap.set(vmName, {
                timestamp: new Date().toISOString(),
                count: (startFailureMap.get(vmName)?.count || 0) + 1
            });
            console.log(`标记虚拟机 ${vmName} 启动失败`);
        }

        // 清除启动失败标记
        function clearStartFailure(vmName) {
            startFailureMap.delete(vmName);
            console.log(`清除虚拟机 ${vmName} 启动失败标记`);
        }

        // 获取启动失败状态
        function getStartFailureStatus(vmName) {
            return startFailureMap.get(vmName) || null;
        }

        // 清除后端启动失败标记
        async function clearBackendStartFailure(vmName) {
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/clear_failure`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    console.log(`清除虚拟机 ${vmName} 后端启动失败标记成功`);
                } else {
                    console.error(`清除虚拟机 ${vmName} 后端启动失败标记失败:`, data.message);
                }
            } catch (error) {
                console.error(`清除虚拟机 ${vmName} 后端启动失败标记失败:`, error);
            }
        }

        // 清除虚拟机异常状态
        async function clearVMException(vmName) {
            try {
                showAlert('info', `正在清除虚拟机 ${vmName} 的操作异常标记...`);
                
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/clear_exception`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                
                if (data.success) {
                    showAlert('success', data.message);
                    // 重新加载虚拟机列表以更新显示
                    loadVMs();
                } else {
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error(`清除虚拟机异常状态失败: ${error}`);
                showAlert('danger', `清除虚拟机异常状态失败: ${error.message}`);
            }
        }

        // 清除虚拟机异常状态（静默模式，不显示提示）
        async function clearVMExceptionBackend(vmName) {
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/clear_exception`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                
                if (data.success) {
                    console.log(`已清除虚拟机 ${vmName} 的操作异常标记`);
                } else {
                    console.error(`清除虚拟机操作异常标记失败: ${data.message}`);
                }
            } catch (error) {
                console.error(`清除虚拟机操作异常标记失败: ${error}`);
            }
        }

        // 日志查看相关变量
        let logsUpdateInterval = null;
        let logsTerminal = null;
        let lastLogCount = 0;
        let isScrolledToBottom = true;
        let lastLogPosition = 0;
        let allLogs = [];

        // 显示日志查看模态框
        function showLogsModal() {
            console.log('显示日志查看模态框');
            const modal = new bootstrap.Modal(document.getElementById('logsModal'));
            modal.show();
            
            // 初始化日志终端
            logsTerminal = document.getElementById('logsTerminal');
            
            // 监听滚动事件
            logsTerminal.addEventListener('scroll', function() {
                const scrollTop = this.scrollTop;
                const scrollHeight = this.scrollHeight;
                const clientHeight = this.clientHeight;
                isScrolledToBottom = (scrollTop + clientHeight >= scrollHeight - 10);
            });
            
            // 开始实时更新日志
            startLogsUpdate();
        }

        // 开始日志更新
        function startLogsUpdate() {
            if (logsUpdateInterval) {
                clearInterval(logsUpdateInterval);
            }
            
            // 立即获取一次日志
            updateLogs();
            
            // 每1秒更新一次日志（更频繁的更新）
            logsUpdateInterval = setInterval(updateLogs, 1000);
        }

        // 停止日志更新
        function stopLogsUpdate() {
            if (logsUpdateInterval) {
                clearInterval(logsUpdateInterval);
                logsUpdateInterval = null;
            }
        }

        // 更新日志显示
        async function updateLogs() {
            try {
                // 使用日志流API获取新日志
                const response = await fetch(`/api/logs/monitor/stream?position=${lastLogPosition}&max_lines=100`);
                const data = await response.json();
                
                if (data.success && logsTerminal) {
                    const newLogs = data.data.logs;
                    const hasNewLogs = data.data.has_new_logs;
                    const currentPosition = data.data.position;
                    
                    // 如果是第一次加载，获取完整日志
                    if (lastLogCount === 0) {
                        const fullResponse = await fetch('/api/logs/monitor');
                        const fullData = await fullResponse.json();
                        if (fullData.success) {
                            allLogs = fullData.data.logs;
                            lastLogCount = allLogs.length;
                            lastLogPosition = data.data.file_size;
                        }
                    } else if (hasNewLogs && newLogs.length > 0) {
                        // 添加新日志到总日志列表
                        allLogs = allLogs.concat(newLogs);
                        lastLogCount = allLogs.length;
                        lastLogPosition = currentPosition;
                    }
                    
                    // 如果有新日志或者第一次加载，更新显示
                    if (lastLogCount > 0) {
                        // 更新日志显示
                        updateLogsDisplay();
                        
                        // 显示日志状态
                        const statusElement = document.getElementById('logsStatus');
                        if (statusElement) {
                            const updateTime = new Date().toLocaleTimeString();
                            
                            // 统计各级别日志数量
                            const levelCounts = {};
                            allLogs.forEach(log => {
                                const level = log.level.toLowerCase();
                                levelCounts[level] = (levelCounts[level] || 0) + 1;
                            });
                            
                            const statusText = hasNewLogs ? 
                                `共 ${lastLogCount} 行日志，有新日志，最后更新: ${updateTime} | DEBUG: ${levelCounts.debug || 0}, INFO: ${levelCounts.info || 0}, WARN: ${levelCounts.warning || 0}, ERROR: ${levelCounts.error || 0}` :
                                `共 ${lastLogCount} 行日志，最后更新: ${updateTime} | DEBUG: ${levelCounts.debug || 0}, INFO: ${levelCounts.info || 0}, WARN: ${levelCounts.warning || 0}, ERROR: ${levelCounts.error || 0}`;
                            statusElement.textContent = statusText;
                        }
                    }
                }
            } catch (error) {
                console.error('更新日志失败:', error);
                if (logsTerminal) {
                    const errorElement = document.createElement('div');
                    errorElement.className = 'text-danger';
                    errorElement.textContent = `日志更新失败: ${error.message}`;
                    logsTerminal.appendChild(errorElement);
                }
            }
        }

        // 复制日志
        function copyLogs() {
            if (logsTerminal) {
                const logsText = logsTerminal.innerText;
                navigator.clipboard.writeText(logsText).then(() => {
                    showAlert('success', '日志已复制到剪贴板');
                }).catch(() => {
                    showAlert('danger', '复制失败，请手动复制');
                });
            }
        }

        // 清空日志
        function clearLogs() {
            if (logsTerminal) {
                logsTerminal.innerHTML = '<div class="text-success">=== 日志已清空 ===</div>';
            }
        }

        // 日志过滤功能
        let currentLogFilter = 'all';
        
        function filterLogs(level) {
            currentLogFilter = level;
            updateLogsDisplay();
        }
        
        function updateLogsDisplay() {
            if (!logsTerminal || allLogs.length === 0) return;
            
            // 清空终端内容
            logsTerminal.innerHTML = '';
            
            // 根据过滤条件显示日志
            const filteredLogs = currentLogFilter === 'all' ? 
                allLogs : 
                allLogs.filter(log => log.level.toLowerCase() === currentLogFilter);
            
            // 添加过滤后的日志内容
            filteredLogs.forEach(log => {
                const logElement = document.createElement('div');
                logElement.className = `log-line ${log.level.toLowerCase()}`;
                
                // 根据日志级别设置颜色和样式
                switch(log.level.toLowerCase()) {
                    case 'error':
                        logElement.className += ' text-danger';
                        break;
                    case 'warning':
                        logElement.className += ' text-warning';
                        break;
                    case 'debug':
                        logElement.className += ' text-muted';
                        break;
                    case 'info':
                        logElement.className += ' text-info';
                        break;
                    case 'critical':
                        logElement.className += ' text-danger fw-bold';
                        break;
                    default:
                        logElement.className += ' text-light';
                        break;
                }
                
                // 如果有模块信息，添加模块标识
                if (log.module) {
                    const moduleSpan = document.createElement('span');
                    moduleSpan.className = 'text-primary fw-bold';
                    moduleSpan.textContent = `[${log.module}] `;
                    logElement.appendChild(moduleSpan);
                }
                
                // 添加日志消息
                const messageSpan = document.createElement('span');
                messageSpan.textContent = log.message;
                logElement.appendChild(messageSpan);
                
                logsTerminal.appendChild(logElement);
            });
            
            // 滚动到底部
            logsTerminal.scrollTop = logsTerminal.scrollHeight;
        }
        
        // 启动动态配置更新
        function startDynamicConfigUpdate() {
            console.log('启动动态配置更新...');
            
            // 每10秒检查一次配置更新，减少API调用频率
            configUpdateInterval = setInterval(async () => {
                // 只在页面可见时执行配置检查
                if (isPageVisible) {
                    try {
                        console.log('=== 执行定期配置检查 ===');
                        updateDynamicUpdateStatus('检查中...', '正在检查配置更新');
                        await checkAndUpdateConfigs();
                        updateDynamicUpdateStatus('运行中', '配置动态更新正常');
                    } catch (error) {
                        console.error('动态配置更新失败:', error);
                        updateDynamicUpdateStatus('错误', '配置动态更新失败');
                    }
                } else {
                    console.log('页面不可见，跳过配置检查');
                }
            }, 10000); // 增加到10秒间隔，减少API调用频率
            
            updateDynamicUpdateStatus('运行中', '动态配置更新已启动');
            console.log('动态配置更新已启动，每10秒检查一次');
        }
        
        // 停止动态配置更新
        function stopDynamicConfigUpdate() {
            if (configUpdateInterval) {
                clearInterval(configUpdateInterval);
                configUpdateInterval = null;
                updateDynamicUpdateStatus('已停止', '动态配置更新已停止');
                console.log('动态配置更新已停止');
            }
        }
        
        // 检查并更新配置
        async function checkAndUpdateConfigs() {
            try {
                const currentTime = Date.now();
                
                // 避免过于频繁的检查，最小间隔5秒
                if (currentTime - lastConfigUpdate < 5000) {
                    console.log('配置检查过于频繁，跳过本次检查');
                    return;
                }
                
                console.log('开始检查配置更新...');
                
                // 检查Web自动刷新配置
                await checkWebRefreshConfig();
                
                // 检查自动监控配置
                await checkAutoMonitorConfig();
                
                lastConfigUpdate = currentTime;
                updateConfigStatus('已同步', '配置动态更新正常');
                
                console.log('配置检查完成，所有配置已同步');
                
            } catch (error) {
                console.error('检查配置更新失败:', error);
                updateConfigStatus('同步失败', '配置动态更新失败');
            }
        }
        
        // 检查Web自动刷新配置
        async function checkWebRefreshConfig() {
            // 检查是否需要节流
            if (shouldThrottleAPI('checkWebRefreshConfig', 8000)) {
                return;
            }
            
            try {
                const response = await fetch('/api/config/web_refresh');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                    const autoRefreshInterval = document.getElementById('autoRefreshInterval');
                    
                    console.log('=== 检查Web自动刷新配置 ===');
                    console.log('配置文件状态:', {
                        button_enabled: config.button_enabled,
                        interval_value: config.interval_value
                    });
                    console.log('UI当前状态:', {
                        autoRefreshToggle: autoRefreshToggle.checked,
                        autoRefreshInterval: autoRefreshInterval.value
                    });
                    
                    let hasChanges = false;
                    
                    // 检查按钮状态是否需要更新
                    const currentButtonState = autoRefreshToggle.checked;
                    const configButtonState = config.button_enabled || false;
                    
                    if (currentButtonState !== configButtonState) {
                        console.log(`Web自动刷新按钮状态需要更新: 当前=${currentButtonState}, 配置=${configButtonState}`);
                        autoRefreshToggle.checked = configButtonState;
                        hasChanges = true;
                        

                        
                        // 如果状态变为启用，启动自动刷新
                        if (configButtonState && !currentButtonState) {
                            console.log('检测到自动刷新已启用，启动自动刷新...');
                            startAutoRefresh();
                        } else if (!configButtonState && currentButtonState) {
                            console.log('检测到自动刷新已禁用，停止自动刷新...');
                            stopAutoRefresh();
                        }
                    } else {
                        console.log('Web自动刷新按钮状态已同步');
                    }
                    
                    // 检查间隔值是否需要更新
                    const currentInterval = parseInt(autoRefreshInterval.value);
                    const configInterval = config.interval_value || 60;
                    
                    if (currentInterval !== configInterval) {
                        console.log(`Web自动刷新间隔需要更新: 当前=${currentInterval}, 配置=${configInterval}`);
                        autoRefreshInterval.value = configInterval;
                        hasChanges = true;
                        
                        // 如果自动刷新正在运行，重新启动以应用新间隔
                        if (autoRefreshToggle.checked) {
                            console.log('检测到间隔已更改，重新启动自动刷新...');
                            startAutoRefresh();
                        }
                    } else {
                        console.log('Web自动刷新间隔已同步');
                    }
                    
                    if (hasChanges) {
                        console.log('检测到Web自动刷新配置变化，更新UI状态');
                    }
                    
                    console.log('=== Web自动刷新配置检查完成 ===');
                }
            } catch (error) {
                console.error('检查Web自动刷新配置失败:', error);
            }
        }
        
        // 强制同步配置
        async function forceSyncConfig() {
            try {
                console.log('=== 强制同步配置开始 ===');
                updateConfigStatus('同步中...', '正在强制同步配置');
                
                // 立即重新加载所有配置
                await loadWebRefreshConfig();
                await loadAutoMonitorConfig();
                
                // 立即检查配置
                await checkWebRefreshConfig();
                await checkAutoMonitorConfig();
                
                updateConfigStatus('已同步', '强制同步配置完成');
                console.log('=== 强制同步配置完成 ===');
                
                // 显示成功提示
                showAlert('success', '配置强制同步完成');
                
            } catch (error) {
                console.error('强制同步配置失败:', error);
                updateConfigStatus('同步失败', '强制同步配置失败');
                showAlert('danger', '强制同步配置失败: ' + error.message);
            }
        }

        // 检查自动监控配置
        async function checkAutoMonitorConfig() {
            // 检查是否需要节流
            if (shouldThrottleAPI('checkAutoMonitorConfig', 8000)) {
                return;
            }
            
            try {
                const response = await fetch('/api/config/auto_monitor');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    const monitoringToggle = document.getElementById('monitoringToggle');
                    const monitorInterval = document.getElementById('monitorInterval');
                    const autoStartToggle = document.getElementById('autoStartToggle');
                    
                    console.log('=== 检查自动监控配置 ===');
                    console.log('配置文件状态:', {
                        button_enabled: config.button_enabled,
                        interval_value: config.interval_value,
                        auto_start_button_enabled: config.auto_start_button_enabled
                    });
                    console.log('UI当前状态:', {
                        monitoringToggle: monitoringToggle.checked,
                        monitorInterval: monitorInterval.value,
                        autoStartToggle: autoStartToggle.checked
                    });
                    
                    let hasChanges = false;
                    
                    // 检查自动监控按钮状态
                    const currentMonitoringState = monitoringToggle.checked;
                    const configMonitoringState = config.button_enabled || false;
                    
                    if (currentMonitoringState !== configMonitoringState) {
                        console.log(`自动监控按钮状态需要更新: 当前=${currentMonitoringState}, 配置=${configMonitoringState}`);
                        monitoringToggle.checked = configMonitoringState;
                        hasChanges = true;
                        
                        // 如果状态变为启用，启动监控
                        if (configMonitoringState && !currentMonitoringState) {
                            console.log('检测到自动监控已启用，启动监控...');
                            const interval = monitorInterval.value;
                            const autoStart = autoStartToggle.checked;
                            startMonitoring(interval, autoStart);
                        } else if (!configMonitoringState && currentMonitoringState) {
                            console.log('检测到自动监控已禁用，停止监控...');
                            stopMonitoring();
                        }
                    } else {
                        console.log('自动监控按钮状态已同步');
                    }
                    
                    // 检查监控间隔
                    const currentMonitorInterval = parseInt(monitorInterval.value);
                    const configMonitorInterval = config.interval_value || 30;
                    
                    if (currentMonitorInterval !== configMonitorInterval) {
                        console.log(`自动监控间隔需要更新: 当前=${currentMonitorInterval}, 配置=${configMonitorInterval}`);
                        monitorInterval.value = configMonitorInterval;
                        hasChanges = true;
                        
                        // 如果监控正在运行，重新启动以应用新间隔
                        if (monitoringToggle.checked) {
                            console.log('检测到监控间隔已更改，重新启动监控...');
                            const autoStart = autoStartToggle.checked;
                            startMonitoring(configMonitorInterval, autoStart);
                        }
                    } else {
                        console.log('自动监控间隔已同步');
                    }
                    
                    // 检查自启动虚拟机按钮状态
                    const currentAutoStartState = autoStartToggle.checked;
                    const configAutoStartState = config.auto_start_button_enabled || false;
                    
                    if (currentAutoStartState !== configAutoStartState) {
                        console.log(`自启动虚拟机按钮状态需要更新: 当前=${currentAutoStartState}, 配置=${configAutoStartState}`);
                        autoStartToggle.checked = configAutoStartState;
                        hasChanges = true;
                        
                        // 如果监控正在运行，重新启动以应用新设置
                        if (monitoringToggle.checked) {
                            console.log('检测到自启动设置已更改，重新启动监控...');
                            const interval = monitorInterval.value;
                            // 使用更新后的UI状态，而不是配置文件中的状态
                            startMonitoring(interval, configAutoStartState);
                        }
                    } else {
                        console.log('自启动虚拟机按钮状态已同步');
                    }
                    
                    if (hasChanges) {
                        console.log('检测到配置变化，更新UI状态');
                        updateConfigStatus('已更新', '检测到配置变化并已同步');
                    }
                    
                    console.log('=== 自动监控配置检查完成 ===');
                }
            } catch (error) {
                console.error('检查自动监控配置失败:', error);
            }
        }
        
        // 更新配置状态显示
        function updateConfigStatus(status, message = '') {
            const configStatusElement = document.getElementById('configStatus');
            if (configStatusElement) {
                configStatusElement.textContent = status;
                configStatusElement.className = status === '已同步' ? 'text-success' : 'text-warning';
                if (message) {
                    console.log(`配置状态: ${status} - ${message}`);
                }
            }
        }
        
        // 更新动态更新状态显示
        function updateDynamicUpdateStatus(status, message = '') {
            const dynamicUpdateStatusElement = document.getElementById('dynamicUpdateStatus');
            if (dynamicUpdateStatusElement) {
                dynamicUpdateStatusElement.textContent = status;
                dynamicUpdateStatusElement.className = status === '运行中' ? 'text-success' : 
                                                    status === '已停止' ? 'text-warning' : 'text-danger';
                if (message) {
                    console.log(`动态更新状态: ${status} - ${message}`);
                }
            }
        }
        
        // 重新加载所有配置
        async function reloadAllConfigs() {
            console.log('重新加载所有配置...');
            updateConfigStatus('同步中...', '正在重新加载配置');
            
            try {
                await loadWebRefreshConfig();
                await loadAutoMonitorConfig();
                console.log('所有配置重新加载完成');
                updateConfigStatus('已同步', '配置重新加载完成');
                showAlert('success', '配置重新加载完成');
            } catch (error) {
                console.error('重新加载配置失败:', error);
                updateConfigStatus('同步失败', '配置重新加载失败');
                showAlert('danger', '配置重新加载失败: ' + error.message);
            }
        }
        
        // 模态框关闭时停止日志更新
        document.getElementById('logsModal').addEventListener('hidden.bs.modal', function() {
            stopLogsUpdate();
        });
        
        // 页面卸载时清理定时器
        window.addEventListener('beforeunload', function() {
            stopDynamicConfigUpdate();
            console.log('页面卸载，清理动态配置更新定时器');
        });

        // 在加载虚拟机列表时添加启动失败标记
        function addStartFailureMarkers(vmList) {
            vmList.forEach(vm => {
                // 检查后端返回的启动失败信息
                if (vm.start_failure) {
                    // 同步到前端缓存
                    startFailureMap.set(vm.name, {
                        timestamp: vm.failure_timestamp,
                        count: vm.failure_count
                    });
                }
                
                // 检查前端缓存的失败信息
                const failureStatus = getStartFailureStatus(vm.name);
                if (failureStatus) {
                    vm.start_failure = true;
                    vm.failure_count = failureStatus.count;
                    vm.failure_timestamp = failureStatus.timestamp;
                }
            });
        }

        // 清除所有启动失败标记
        async function clearAllStartFailures() {
            try {
                const response = await fetch('/api/vm/clear_all_failures', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('清除所有启动失败标记成功');
                    showAlert('success', data.message);
                    startFailureMap.clear(); // 清除前端缓存
                    loadVMs(); // 重新加载虚拟机列表以更新显示
                } else {
                    console.error('清除启动失败标记失败:', data.message);
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error('清除启动失败标记失败:', error);
                showAlert('danger', '清除启动失败标记失败: ' + error.message);
            }
        }

        // 退出登录
        async function logout() {
            if (confirm('确定要退出登录吗？')) {
                try {
                    const response = await fetch('/logout', {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        window.location.href = '/login';
                    } else {
                        showAlert('danger', '退出失败');
                    }
                } catch (error) {
                    console.error('退出失败:', error);
                    showAlert('danger', '退出失败: ' + error.message);
                }
            }
        }
    </script>
</body>
</html> 