<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VirtualBox虚拟机监控系统</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .status-badge {
            font-size: 0.8em;
        }
        .vm-card {
            transition: all 0.3s ease;
        }
        .vm-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .monitoring-active {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
        }
        .monitoring-inactive {
            background-color: #f8d7da !important;
            border-color: #f5c6cb !important;
        }
        .refresh-spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .auto-refresh {
            background-color: #e7f3ff;
            border-left: 4px solid #007bff;
        }
        
        /* 虚拟机列表容器样式 */
        .vm-list-container {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1rem;
        }
        
        /* 虚拟机列表滚动条样式 */
        .vm-list-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .vm-list-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .vm-list-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        
        .vm-list-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        /* 确保页面整体高度固定 */
        .container-fluid {
            height: 100vh;
            overflow: hidden;
        }
        
        /* 头部区域固定高度 */
        .bg-primary {
            flex-shrink: 0;
        }
        
        /* 控制面板区域固定高度 */
        .row.mt-3:first-of-type {
            flex-shrink: 0;
        }
        
        /* 虚拟机列表卡片区域 */
        .vm-list-card {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .vm-list-card .card-body {
            flex: 1;
            overflow: hidden;
            padding: 0;
        }
        
        /* 确保虚拟机卡片在滚动容器中正常显示 */
        .vm-list-container .row {
            margin: 0;
        }
        
        .vm-list-container .col-md-6,
        .vm-list-container .col-lg-4 {
            padding: 0.5rem;
        }
        
        /* 启动失败虚拟机样式 */
        .vm-card.border-danger {
            border-width: 2px !important;
            box-shadow: 0 0 10px rgba(220, 53, 69, 0.3);
        }
        
        .vm-card.border-danger .card-header {
            background-color: rgba(220, 53, 69, 0.1);
        }
        
        .vm-card.border-danger:hover {
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.5);
        }
        
        /* 启动失败图标动画 */
        .fa-times-circle {
            animation: pulse-red 2s infinite;
        }
        
        @keyframes pulse-red {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* 异常状态虚拟机样式 */
        .vm-card.border-warning {
            border-width: 2px !important;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }
        
        .vm-card.border-warning .card-header {
            background-color: rgba(255, 193, 7, 0.1);
        }
        
        .vm-card.border-warning:hover {
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
        }
        
        /* 异常状态图标动画 */
        .fa-exclamation-triangle {
            animation: pulse-warning 2s infinite;
        }
        
        @keyframes pulse-warning {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* 小尺寸警告框 */
        .alert-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }

        /* 日志终端样式 */
        .log-line {
            margin: 0;
            padding: 1px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .log-line.debug {
            color: #6c757d;
        }

        .log-line.info {
            color: #17a2b8;
        }

        .log-line.warning {
            color: #ffc107;
        }

        .log-line.error {
            color: #dc3545;
        }

        .log-line.critical {
            color: #dc3545;
            font-weight: bold;
        }
        
        .log-line .text-primary {
            color: #007bff !important;
        }
        
        .log-line .text-info {
            color: #17a2b8 !important;
        }
        
        .log-line .text-warning {
            color: #ffc107 !important;
        }
        
        .log-line .text-danger {
            color: #dc3545 !important;
        }
        
        .log-line .text-muted {
            color: #6c757d !important;
        }
        
        .log-line .fw-bold {
            font-weight: bold !important;
        }

        #logsTerminal {
            background-color: #1e1e1e !important;
            border: none;
            outline: none;
        }

        #logsTerminal::-webkit-scrollbar {
            width: 8px;
        }

        #logsTerminal::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        #logsTerminal::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        #logsTerminal::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <div class="container-fluid d-flex flex-column">
        <!-- 头部 -->
        <div class="row bg-primary text-white p-3 flex-shrink-0">
            <div class="col">
                <h3><i class="fas fa-server me-2"></i>VirtualBox虚拟机监控系统</h3>
                <p class="mb-0">实时监控和管理VirtualBox虚拟机</p>
            </div>
            <div class="col-auto">
                <div class="d-flex align-items-center">
                    <span class="me-3">
                        <i class="fas fa-user me-1"></i>
                        欢迎，{{ session.get('username', 'admin') }}
                    </span>
                    <button class="btn btn-outline-light btn-sm" onclick="logout()">
                        <i class="fas fa-sign-out-alt me-1"></i>退出
                    </button>
                </div>
            </div>
        </div>

        <!-- 控制面板 -->
        <div class="row mt-3 flex-shrink-0">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-cogs me-2"></i>监控控制</h5>
                        <div>
                            <button id="refreshBtn" class="btn btn-outline-primary btn-sm">
                                <i class="fas fa-sync-alt me-1"></i>刷新
                            </button>
                            <button id="scanBtn" class="btn btn-outline-info btn-sm ms-2">
                                <i class="fas fa-search me-1"></i>扫描
                            </button>
                            <button id="reloadConfigBtn" class="btn btn-outline-warning btn-sm ms-2" onclick="reloadAllConfigs()" title="重新加载配置">
                                <i class="fas fa-cog me-1"></i>重载配置
                            </button>
                            <button id="checkConfigBtn" class="btn btn-outline-info btn-sm ms-2" onclick="checkAndUpdateConfigs()" title="立即检查配置">
                                <i class="fas fa-sync-alt me-1"></i>检查配置
                            </button>
                            <button id="debugConfigBtn" class="btn btn-outline-secondary btn-sm ms-2" onclick="checkAutoMonitorConfig()" title="调试自动监控配置">
                                <i class="fas fa-bug me-1"></i>调试配置
                            </button>
                            <button id="forceSyncBtn" class="btn btn-outline-warning btn-sm ms-2" onclick="forceSyncConfig()" title="强制同步配置">
                                <i class="fas fa-sync-alt fa-spin me-1"></i>强制同步
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="d-flex align-items-center mb-3">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="autoRefreshToggle">
                                        <label class="form-check-label" for="autoRefreshToggle">
                                            自动刷新
                                        </label>
                                    </div>
                                    <select id="autoRefreshInterval" class="form-select form-select-sm" style="width: 120px;">
                                        <option value="30" selected>30秒</option>
                                        <option value="60">1分钟</option>
                                        <option value="300">5分钟</option>
                                        <option value="600">10分钟</option>
                                    </select>
                                </div>
                                <div class="mb-2">
                                    <small class="text-muted">
                                        <strong>自动刷新状态:</strong> <span id="autoRefreshStatus"><span class="badge bg-secondary">已禁用</span></span>
                                    </small>
                                </div>
                                <div class="d-flex align-items-center mb-3">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="monitoringToggle">
                                        <label class="form-check-label" for="monitoringToggle">
                                            自动监控
                                        </label>
                                    </div>
                                    <select id="monitorInterval" class="form-select form-select-sm" style="width: 120px;">
                                        <option value="30" selected>30秒</option>
                                        <option value="60">1分钟</option>
                                        <option value="300">5分钟</option>
                                        <option value="600">10分钟</option>
                                    </select>
                                </div>

                                <div class="d-flex align-items-center mt-2">
                                    <div class="form-check form-switch me-3">
                                        <input class="form-check-input" type="checkbox" id="autoStartToggle">
                                        <label class="form-check-label" for="autoStartToggle">
                                            自启动虚拟机
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="alert alert-info mb-0">
                                    <small>
                                        <i class="fas fa-info-circle me-1"></i>
                                        <strong>监控状态:</strong> <span id="monitorStatus">未启动</span><br>
                                        <strong>监控模式:</strong> <span id="monitorMode">-</span><br>
                                        <strong>虚拟机数量:</strong> <span id="vmCount">0</span><br>
                                        <strong>最后更新:</strong> <span id="lastUpdate">-</span><br>
                                        <strong>选中目录:</strong> <span id="selectedDirectories">-</span><br>
                                        <strong>配置状态:</strong> <span id="configStatus">已同步</span><br>
                                        <strong>动态更新:</strong> <span id="dynamicUpdateStatus">运行中</span>
                                    </small>
                                </div>
                                <div class="mt-2">
                                    <button id="viewLogsBtn" class="btn btn-outline-info btn-sm">
                                        <i class="fas fa-terminal me-1"></i>查看日志
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-bolt me-2"></i>快速操作</h5>
                    </div>
                    <div class="card-body">
                        <button id="autoStartBtn" class="btn btn-success w-100 mb-2">
                            <i class="fas fa-play me-1"></i>启动所有已停止的虚拟机
                        </button>
                        <button id="startAllBtn" class="btn btn-primary w-100 mb-2">
                            <i class="fas fa-power-off me-1"></i>启动所有虚拟机
                        </button>
                        <button id="stopAllBtn" class="btn btn-warning w-100 mb-2">
                            <i class="fas fa-stop me-1"></i>停止所有虚拟机
                        </button>
                        <button id="clearFailuresBtn" class="btn btn-outline-danger w-100 mb-2">
                            <i class="fas fa-times-circle me-1"></i>清除失败标记
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 虚拟机列表 -->
        <div class="row mt-3 flex-grow-1">
            <div class="col-12">
                <div class="card vm-list-card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-list me-2"></i>虚拟机列表</h5>
                    </div>
                    <div class="card-body">
                        <div class="vm-list-container">
                            <div id="vmList" class="row">
                                <!-- 虚拟机卡片将在这里动态生成 -->
                            </div>
                            <div id="noVmsMessage" class="text-center text-muted py-5" style="display: none;">
                                <i class="fas fa-server fa-3x mb-3"></i>
                                <h5>未发现虚拟机</h5>
                                <p>请检查VirtualBox是否正确安装，或点击"扫描"按钮重新扫描</p>
                            </div>
                            <div id="loadingMessage" class="text-center py-5">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">加载中...</span>
                                </div>
                                <p class="mt-2">正在加载虚拟机信息...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 虚拟机详情模态框 -->
        <div class="modal fade" id="vmDetailModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">虚拟机详情</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div id="vmDetailContent">
                            <!-- 虚拟机详细信息将在这里显示 -->
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <!-- 日志查看模态框 -->
    <div class="modal fade" id="logsModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-terminal me-2"></i>监控日志查看器
                    </h5>
                    <div class="btn-group">
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="copyLogs()" title="复制日志">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button type="button" class="btn btn-outline-danger btn-sm" onclick="clearLogs()" title="清空日志">
                            <i class="fas fa-trash"></i>
                        </button>
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-outline-info btn-sm" onclick="filterLogs('all')" title="显示所有日志">
                                全部
                            </button>
                            <button type="button" class="btn btn-outline-warning btn-sm" onclick="filterLogs('error')" title="只显示错误日志">
                                错误
                            </button>
                            <button type="button" class="btn btn-outline-info btn-sm" onclick="filterLogs('info')" title="只显示信息日志">
                                信息
                            </button>
                        </div>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                </div>
                <div class="modal-body p-0">
                    <div class="bg-secondary text-light p-2" style="font-size: 11px; border-bottom: 1px solid #495057;">
                        <span id="logsStatus">正在连接日志流...</span>
                    </div>
                    <div id="logsTerminal" class="bg-dark text-light p-3" style="height: 480px; font-family: 'Courier New', monospace; font-size: 12px; overflow-y: auto;">
                        <div class="text-success">=== 监控日志查看器已启动 ===</div>
                        <div class="text-info">正在连接日志流...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 全局变量
        let autoRefreshInterval = null;
        let monitoringInterval = null;
        let vmList = [];
        let configUpdateInterval = null; // 配置更新定时器
        let lastConfigUpdate = 0; // 上次配置更新时间
        let lastVMLoadTime = 0; // 上次虚拟机加载时间
        let apiCallThrottle = {}; // API调用节流控制

        // 页面可见性检测
        let isPageVisible = true;
        
        document.addEventListener('visibilitychange', function() {
            isPageVisible = !document.hidden;
            console.log(`页面可见性变化: ${isPageVisible ? '可见' : '隐藏'}`);
            
            if (isPageVisible) {
                // 页面变为可见时，延迟更新数据，避免频繁调用
                console.log('页面变为可见，延迟更新数据');
                setTimeout(() => {
                    if (isPageVisible) { // 再次检查，确保页面仍然可见
                        loadVMs();
                        loadMonitorStatus();
                    }
                }, 1000); // 延迟1秒，避免频繁切换时的重复调用
            }
        });

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，开始初始化...');
            loadVMs();
            loadMonitorStatus();
            loadVboxDirConfig();
            loadAutoMonitorConfig();
            loadWebRefreshConfig();
            setupEventListeners();
            
            // 启动动态配置更新
            startDynamicConfigUpdate();
            
            // 延迟2秒后进行第一次配置检查，确保配置同步
            setTimeout(async () => {
                console.log('执行首次配置检查...');
                await checkAndUpdateConfigs();
                console.log('首次配置检查完成');
            }, 2000);
        });

        // 设置事件监听器
        function setupEventListeners() {
            // 刷新按钮
            document.getElementById('refreshBtn').addEventListener('click', function() {
                this.querySelector('i').classList.add('refresh-spinner');
                loadVMs().finally(() => {
                    this.querySelector('i').classList.remove('refresh-spinner');
                });
            });

            // 扫描按钮
            document.getElementById('scanBtn').addEventListener('click', function() {
                this.disabled = true;
                this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>扫描中...';
                
                fetch('/api/scan')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showAlert('success', `扫描完成，发现 ${data.data.length} 个虚拟机`);
                            // 延迟加载虚拟机列表，避免频繁调用
                            setTimeout(() => {
                                if (isPageVisible) {
                                    loadVMs();
                                }
                            }, 1000); // 延迟1秒，等待扫描完成
                        } else {
                            showAlert('danger', data.message);
                        }
                    })
                    .catch(error => {
                        showAlert('danger', '扫描失败: ' + error.message);
                    })
                    .finally(() => {
                        this.disabled = false;
                        this.innerHTML = '<i class="fas fa-search me-1"></i>扫描';
                    });
            });

            // 自动刷新开关
            document.getElementById('autoRefreshToggle').addEventListener('change', function() {
                const enabled = this.checked;
                
                console.log(`自动刷新按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 直接更新配置文件中的AUTO_REFRESH_BUTTON_ENABLED
                updateConfigParameter('AUTO_REFRESH_BUTTON_ENABLED', enabled).then(() => {
                    // 配置更新成功后，立即通知后台重新加载配置
                    console.log('自动刷新按钮状态已更新，立即通知后台重新加载配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在通知后台');
                    
                    // 通知后台重新加载配置
                    fetch('/api/config/auto_refresh/reload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }).then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('后台自动刷新配置重新加载成功:', data.data);
                            updateConfigStatus('已同步', '后台配置已更新');
                        } else {
                            console.error('后台自动刷新配置重新加载失败:', data.message);
                            updateConfigStatus('同步失败', '后台配置更新失败');
                        }
                    }).catch(error => {
                        console.error('通知后台重新加载配置失败:', error);
                        updateConfigStatus('同步失败', '后台配置更新失败');
                    });
                    
                    if (enabled) {
                        console.log('自动刷新已启用，启动自动刷新...');
                        startAutoRefresh();
                    } else {
                        console.log('自动刷新已禁用，停止自动刷新...');
                        stopAutoRefresh();
                    }
                });
            });

            // 自动刷新间隔变化
            document.getElementById('autoRefreshInterval').addEventListener('change', function() {
                const interval = parseInt(this.value);
                const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                
                console.log(`自动刷新间隔变更: ${interval}秒`);
                
                // 直接更新配置文件中的AUTO_REFRESH_INTERVAL_VALUE
                updateConfigParameter('AUTO_REFRESH_INTERVAL_VALUE', interval).then(() => {
                    // 配置更新成功后，立即通知后台重新加载配置
                    console.log('自动刷新间隔已更新，立即通知后台重新加载配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在通知后台');
                    
                    // 通知后台重新加载配置
                    fetch('/api/config/auto_refresh/reload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }).then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('后台自动刷新配置重新加载成功:', data.data);
                            updateConfigStatus('已同步', '后台配置已更新');
                        } else {
                            console.error('后台自动刷新配置重新加载失败:', data.message);
                            updateConfigStatus('同步失败', '后台配置更新失败');
                        }
                    }).catch(error => {
                        console.error('通知后台重新加载配置失败:', error);
                        updateConfigStatus('同步失败', '后台配置更新失败');
                    });
                    
                    if (autoRefreshToggle.checked) {
                        // 如果自动刷新正在运行，立即重新启动以应用新间隔
                        console.log('自动刷新已启用，立即应用新间隔设置');
                        startAutoRefresh();
                    } else {
                        // 如果自动刷新未启用，只更新UI显示
                        console.log('自动刷新未启用，仅更新显示');
                        updateAutoRefreshStatus(false, interval);
                    }
                });
            });

            // 监控开关
            document.getElementById('monitoringToggle').addEventListener('change', function() {
                const enabled = this.checked;
                const interval = document.getElementById('monitorInterval').value;
                const autoStart = document.getElementById('autoStartToggle').checked;
                
                console.log(`自动监控按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 直接更新配置文件中的AUTO_MONITOR_BUTTON_ENABLED
                updateConfigParameter('AUTO_MONITOR_BUTTON_ENABLED', enabled).then(() => {
                    // 配置更新成功后，延迟重新加载配置以确保UI状态正确
                    console.log('自动监控按钮状态已更新，延迟重新加载自动监控配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在重新加载');
                    setTimeout(() => {
                        loadAutoMonitorConfig();
                        updateConfigStatus('已同步', '配置重新加载完成');
                    }, 500); // 延迟500ms确保配置已写入
                });
                
                if (enabled) {
                    console.log('自动监控已启用，启动监控...');
                    startMonitoring(interval, autoStart);
                } else {
                    console.log('自动监控已禁用，停止监控...');
                    stopMonitoring();
                }
            });

            // 监控间隔变化
            document.getElementById('monitorInterval').addEventListener('change', function() {
                const interval = parseInt(this.value);
                const monitoringToggle = document.getElementById('monitoringToggle');
                
                console.log(`自动监控间隔变更: ${interval}秒`);
                
                // 直接更新配置文件中的AUTO_MONITOR_INTERVAL_VALUE
                updateConfigParameter('AUTO_MONITOR_INTERVAL_VALUE', interval).then(() => {
                    // 配置更新成功后，延迟重新加载配置以确保UI状态正确
                    console.log('自动监控间隔已更新，延迟重新加载自动监控配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在重新加载');
                    setTimeout(() => {
                        loadAutoMonitorConfig();
                        updateConfigStatus('已同步', '配置重新加载完成');
                    }, 500); // 延迟500ms确保配置已写入
                });
                
                if (monitoringToggle.checked) {
                    // 如果监控正在运行，重新启动监控以应用新设置
                    const autoStart = document.getElementById('autoStartToggle').checked;
                    console.log('自动监控已启用，立即应用新间隔设置');
                    startMonitoring(interval, autoStart);
                } else {
                    // 如果监控未启用，只更新显示，不保存配置
                    console.log('自动监控未启用，仅更新显示，不保存配置');
                }
            });

            // 自动启动开关
            document.getElementById('autoStartToggle').addEventListener('change', function() {
                const enabled = this.checked;
                const monitoringToggle = document.getElementById('monitoringToggle');
                
                console.log(`自启动虚拟机按钮状态变更: ${enabled ? '开启' : '关闭'}`);
                
                // 直接更新配置文件中的AUTO_START_VM_BUTTON_ENABLED
                updateConfigParameter('AUTO_START_VM_BUTTON_ENABLED', enabled).then(() => {
                    // 配置更新成功后，延迟重新加载配置以确保UI状态正确
                    console.log('自启动虚拟机按钮状态已更新，延迟重新加载自动监控配置...');
                    updateConfigStatus('同步中...', '配置已更新，正在重新加载');
                    setTimeout(() => {
                        loadAutoMonitorConfig();
                        updateConfigStatus('已同步', '配置重新加载完成');
                    }, 500); // 延迟500ms确保配置已写入
                });
                
                if (monitoringToggle.checked) {
                    // 如果监控正在运行，重新启动监控以应用新设置
                    const interval = document.getElementById('monitorInterval').value;
                    const autoStart = enabled;
                    console.log('自动监控已启用，立即应用新设置');
                    startMonitoring(interval, autoStart);
                } else {
                    // 如果监控未启用，只更新显示，不保存配置
                    console.log('自动监控未启用，仅更新显示，不保存配置');
                }
            });

            // 日志查看按钮
            document.getElementById('viewLogsBtn').addEventListener('click', function() {
                showLogsModal();
            });

            // 快速操作按钮
            document.getElementById('autoStartBtn').addEventListener('click', function() {
                this.disabled = true;
                this.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>执行中...';
                
                fetch('/api/auto_start')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            showAlert('success', data.message);
                            loadVMs();
                        } else {
                            showAlert('danger', data.message);
                        }
                    })
                    .catch(error => {
                        showAlert('danger', '自动启动失败: ' + error.message);
                    })
                    .finally(() => {
                        this.disabled = false;
                        this.innerHTML = '<i class="fas fa-play me-1"></i>启动所有已停止的虚拟机';
                    });
            });

            document.getElementById('startAllBtn').addEventListener('click', function() {
                if (confirm('确定要启动所有虚拟机吗？')) {
                    startAllVMs();
                }
            });

            document.getElementById('stopAllBtn').addEventListener('click', function() {
                if (confirm('确定要停止所有虚拟机吗？')) {
                    stopAllVMs();
                }
            });

            document.getElementById('clearFailuresBtn').addEventListener('click', function() {
                if (confirm('确定要清除所有启动失败标记吗？')) {
                    clearAllStartFailures();
                }
            });


        }

        // 智能API调用节流函数
        function shouldThrottleAPI(apiName, minInterval = 5000) {
            const now = Date.now();
            const lastCall = apiCallThrottle[apiName] || 0;
            
            if (now - lastCall < minInterval) {
                console.log(`API调用过于频繁，跳过 ${apiName} 调用 (间隔: ${now - lastCall}ms, 最小间隔: ${minInterval}ms)`);
                return true;
            }
            
            apiCallThrottle[apiName] = now;
            console.log(`API调用 ${apiName} 已记录，时间: ${new Date().toLocaleTimeString()}`);
            return false;
        }

        // 加载虚拟机列表
        async function loadVMs() {
            // 从配置文件获取自动刷新间隔，作为节流时间
            const autoRefreshIntervalElement = document.getElementById('autoRefreshInterval');
            const refreshInterval = parseInt(autoRefreshIntervalElement.value) || 60;
            const throttleTime = Math.max(refreshInterval * 1000, 30000); // 最小30秒
            
            // 检查是否需要节流
            if (shouldThrottleAPI('loadVMs', throttleTime)) {
                return;
            }
            
            console.log('开始加载虚拟机列表...');
            try {
                console.log('发送请求到 /api/vms');
                const response = await fetch('/api/vms');
                console.log('收到响应:', response.status, response.statusText);
                
                const data = await response.json();
                console.log('解析响应数据:', data);
                
                if (data.success) {
                    vmList = data.data;
                    console.log(`获取到 ${vmList.length} 个虚拟机:`, vmList);
                    
                    // 添加启动失败标记
                    addStartFailureMarkers(vmList);
                    
                    displayVMs(vmList);
                    updateLastUpdate(data.timestamp);
                    updateVMCount(vmList.length);
                    lastVMLoadTime = Date.now();
                } else {
                    console.error('API返回错误:', data.message);
                    showAlert('danger', data.message);
                    displayVMs([]);
                }
            } catch (error) {
                console.error('加载虚拟机列表失败:', error);
                showAlert('danger', '加载虚拟机列表失败: ' + error.message);
                displayVMs([]);
            }
        }

        // 显示虚拟机列表
        function displayVMs(vms) {
            const vmListContainer = document.getElementById('vmList');
            const noVmsMessage = document.getElementById('noVmsMessage');
            const loadingMessage = document.getElementById('loadingMessage');

            // 隐藏加载消息
            loadingMessage.style.display = 'none';

            if (vms.length === 0) {
                vmListContainer.innerHTML = '';
                noVmsMessage.style.display = 'block';
                return;
            }

            noVmsMessage.style.display = 'none';
            
            vmListContainer.innerHTML = vms.map(vm => createVMCard(vm)).join('');
        }

        // 创建虚拟机卡片
        function createVMCard(vm) {
            console.log(`创建虚拟机卡片: ${vm.name}, 状态: ${vm.status}`);
            const statusClass = getStatusClass(vm.status);
            const statusText = getStatusText(vm.status);
            const statusIcon = getStatusIcon(vm.status);
            
            // 检查是否有启动失败标记
            const hasStartFailure = vm.start_failure || false;
            const failureClass = hasStartFailure ? 'border-danger' : '';
            const failureIcon = hasStartFailure ? '<i class="fas fa-times-circle text-danger me-1" title="启动失败"></i>' : '';
            
            // 检查是否有异常状态
            const hasException = vm.exception || false;
            const exceptionClass = hasException ? 'border-warning' : '';
            const exceptionIcon = hasException ? '<i class="fas fa-exclamation-triangle text-warning me-1" title="虚拟机操作异常"></i>' : '';
            
            return `
                <div class="col-md-6 col-lg-4 mb-3">
                    <div class="card vm-card h-100 ${failureClass} ${exceptionClass}">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h6 class="mb-0 text-truncate" title="${vm.name}">
                                ${failureIcon}${exceptionIcon}<i class="fas fa-server me-1"></i>${vm.name}
                            </h6>
                            <span class="badge ${statusClass} status-badge">
                                ${statusIcon} ${statusText}
                            </span>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-8">
                                    <small class="text-muted">
                                        <i class="fas fa-fingerprint me-1"></i>UUID: ${vm.uuid.substring(0, 8)}...
                                    </small><br>
                                    <small class="text-muted">
                                        <i class="fas fa-clock me-1"></i>最后检查: ${formatTime(vm.last_check)}
                                    </small>
                                    ${hasStartFailure ? `<br><small class="text-danger"><i class="fas fa-exclamation-triangle me-1"></i>启动失败 (${vm.failure_count || 1}次)</small>` : ''}
                                    ${hasException ? `<br><small class="text-warning"><i class="fas fa-exclamation-triangle me-1"></i>操作异常 (${vm.exception_count || 1}次)</small>` : ''}
                                </div>
                                <div class="col-4 text-end">
                                    <div class="btn-group-vertical btn-group-sm">
                                        ${vm.status === 'poweroff' || vm.status === 'aborted' ? 
                                            `<button class="btn btn-success btn-sm" onclick="startVM('${vm.name}')" title="启动">
                                                <i class="fas fa-play"></i>
                                            </button>` : 
                                            `<button class="btn btn-warning btn-sm" onclick="stopVM('${vm.name}')" title="停止">
                                                <i class="fas fa-stop"></i>
                                            </button>`
                                        }
                                        <button class="btn btn-info btn-sm" onclick="showVMDetail('${vm.name}')" title="详情">
                                            <i class="fas fa-info-circle"></i>
                                        </button>
                                        ${hasException ? `
                                        <button class="btn btn-outline-warning btn-sm" onclick="clearVMException('${vm.name}')" title="清除操作异常标记">
                                            <i class="fas fa-times"></i>
                                        </button>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            `;
        }

        // 获取状态样式类
        function getStatusClass(status) {
            console.log(`获取状态样式类，原始状态: ${status}`);
            switch (status) {
                case 'running': return 'bg-success';
                case 'poweroff': return 'bg-secondary';
                case 'paused': return 'bg-warning';
                case 'saved': return 'bg-info';
                case 'aborted': return 'bg-danger';
                case 'unknown': return 'bg-dark';
                default: 
                    console.warn(`未知状态值: ${status}`);
                    return 'bg-dark';
            }
        }

        // 获取状态文本
        function getStatusText(status) {
            console.log(`获取状态文本，原始状态: ${status}`);
            switch (status) {
                case 'running': return '运行中';
                case 'poweroff': return '已关闭';
                case 'paused': return '已暂停';
                case 'saved': return '已保存';
                case 'aborted': return '异常终止';
                case 'unknown': return '未知状态';
                default: 
                    console.warn(`未知状态值: ${status}`);
                    return '未知状态';
            }
        }

        // 获取状态图标
        function getStatusIcon(status) {
            console.log(`获取状态图标，原始状态: ${status}`);
            switch (status) {
                case 'running': return '<i class="fas fa-play"></i>';
                case 'poweroff': return '<i class="fas fa-stop"></i>';
                case 'paused': return '<i class="fas fa-pause"></i>';
                case 'saved': return '<i class="fas fa-save"></i>';
                case 'aborted': return '<i class="fas fa-exclamation-triangle"></i>';
                case 'unknown': return '<i class="fas fa-question"></i>';
                default: 
                    console.warn(`未知状态值: ${status}`);
                    return '<i class="fas fa-question"></i>';
            }
        }

        // 格式化时间
        function formatTime(timestamp) {
            if (!timestamp) return '-';
            const date = new Date(timestamp);
            return date.toLocaleString('zh-CN');
        }

        // 启动虚拟机
        async function startVM(vmName) {
            console.log(`开始启动虚拟机: ${vmName}`);
            try {
                const url = `/api/vm/${encodeURIComponent(vmName)}/start`;
                console.log('发送请求到:', url);
                const response = await fetch(url);
                console.log('收到响应:', response.status, response.statusText);
                
                const data = await response.json();
                console.log('解析响应数据:', data);
                
                if (data.success) {
                    console.log(`虚拟机 ${vmName} 启动成功`);
                    showAlert('success', data.message);
                    // 清除启动失败标记
                    clearStartFailure(vmName);
                    // 清除后端失败标记
                    clearBackendStartFailure(vmName);
                    // 清除异常状态
                    await clearVMExceptionBackend(vmName);
                    // 延迟加载虚拟机列表，避免频繁调用
                    setTimeout(() => {
                        if (isPageVisible) {
                            loadVMs();
                        }
                    }, 1000); // 延迟1秒，等待状态稳定
                } else {
                    console.error(`虚拟机 ${vmName} 启动失败:`, data.message);
                    showAlert('danger', data.message);
                    // 标记启动失败
                    markStartFailure(vmName);
                    // 延迟加载虚拟机列表，避免频繁调用
                    setTimeout(() => {
                        if (isPageVisible) {
                            loadVMs();
                        }
                    }, 1000); // 延迟1秒，等待状态稳定
                }
            } catch (error) {
                console.error(`启动虚拟机 ${vmName} 失败:`, error);
                showAlert('danger', '启动虚拟机失败: ' + error.message);
                // 标记启动失败
                markStartFailure(vmName);
                // 延迟加载虚拟机列表，避免频繁调用
                setTimeout(() => {
                    if (isPageVisible) {
                        loadVMs();
                    }
                }, 1000); // 延迟1秒，等待状态稳定
            }
        }

        // 停止虚拟机
        async function stopVM(vmName) {
            if (!confirm(`确定要停止虚拟机 "${vmName}" 吗？`)) {
                return;
            }

            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/stop`);
                const data = await response.json();
                
                if (data.success) {
                    showAlert('success', data.message);
                    // 清除异常状态
                    await clearVMExceptionBackend(vmName);
                    // 延迟加载虚拟机列表，避免频繁调用
                    setTimeout(() => {
                        if (isPageVisible) {
                            loadVMs();
                        }
                    }, 1000); // 延迟1秒，等待状态稳定
                } else {
                    showAlert('danger', data.message);
                }
            } catch (error) {
                showAlert('danger', '停止虚拟机失败: ' + error.message);
            }
        }









        // 显示虚拟机详情
        async function showVMDetail(vmName) {
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/info`);
                const data = await response.json();
                
                const modal = new bootstrap.Modal(document.getElementById('vmDetailModal'));
                const content = document.getElementById('vmDetailContent');
                
                if (data.success) {
                    content.innerHTML = createVMDetailHTML(vmName, data.data);
                } else {
                    content.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                }
                
                modal.show();
            } catch (error) {
                showAlert('danger', '获取虚拟机详情失败: ' + error.message);
            }
        }

        // 创建虚拟机详情HTML
        function createVMDetailHTML(vmName, info) {
            let html = `<h6>虚拟机: ${vmName}</h6><hr>`;
            
            for (const [key, value] of Object.entries(info)) {
                html += `<div class="row mb-2">
                    <div class="col-4"><strong>${key}:</strong></div>
                    <div class="col-8">${value}</div>
                </div>`;
            }
            
            return html;
        }

        // 启动所有虚拟机
        async function startAllVMs() {
            const stoppedVMs = vmList.filter(vm => vm.status === 'poweroff' || vm.status === 'aborted');
            
            if (stoppedVMs.length === 0) {
                showAlert('info', '没有需要启动的虚拟机');
                return;
            }

            let successCount = 0;
            for (const vm of stoppedVMs) {
                try {
                    const response = await fetch(`/api/vm/${encodeURIComponent(vm.name)}/start`);
                    const data = await response.json();
                    if (data.success) {
                        successCount++;
                    }
                } catch (error) {
                    console.error(`启动虚拟机 ${vm.name} 失败:`, error);
                }
            }

            showAlert('success', `批量启动完成，成功启动 ${successCount}/${stoppedVMs.length} 个虚拟机`);
            // 延迟加载虚拟机列表，避免频繁调用
            setTimeout(() => {
                if (isPageVisible) {
                    loadVMs();
                }
            }, 2000); // 延迟2秒，等待虚拟机状态稳定
        }

        // 停止所有虚拟机
        async function stopAllVMs() {
            const runningVMs = vmList.filter(vm => vm.status === 'running');
            
            if (runningVMs.length === 0) {
                showAlert('info', '没有正在运行的虚拟机');
                return;
            }

            let successCount = 0;
            for (const vm of runningVMs) {
                try {
                    const response = await fetch(`/api/vm/${encodeURIComponent(vm.name)}/stop`);
                    const data = await response.json();
                    if (data.success) {
                        successCount++;
                    }
                } catch (error) {
                    console.error(`停止虚拟机 ${vm.name} 失败:`, error);
                }
            }

            showAlert('success', `批量停止完成，成功停止 ${successCount}/${runningVMs.length} 个虚拟机`);
            // 延迟加载虚拟机列表，避免频繁调用
            setTimeout(() => {
                if (isPageVisible) {
                    loadVMs();
                }
            }, 2000); // 延迟2秒，等待虚拟机状态稳定
        }

        // 自动刷新控制
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            // 从配置文件获取间隔时间，确保与前台设置一致
            const autoRefreshIntervalElement = document.getElementById('autoRefreshInterval');
            const interval = parseInt(autoRefreshIntervalElement.value) * 1000; // 转换为毫秒
            
            // 避免过短的刷新间隔，最小30秒
            const minInterval = 30000; // 30秒
            const actualInterval = Math.max(interval, minInterval);
            
            console.log(`自动刷新配置: 前台设置=${interval/1000}秒, 实际间隔=${actualInterval/1000}秒`);
            
            autoRefreshInterval = setInterval(() => {
                // 只在页面可见时执行自动刷新
                if (isPageVisible) {
                    console.log(`[${new Date().toLocaleTimeString()}] 执行自动刷新 (间隔: ${actualInterval/1000}秒)...`);
                    loadVMs();
                } else {
                    console.log(`[${new Date().toLocaleTimeString()}] 页面不可见，跳过自动刷新`);
                }
            }, actualInterval);
            
            // 更新状态显示
            updateAutoRefreshStatus(true, actualInterval / 1000);
            console.log(`自动刷新已启动，间隔: ${actualInterval/1000}秒`);
            
            // 避免频繁保存配置，只在必要时保存
            if (actualInterval !== interval) {
                console.log('检测到刷新间隔过短，已调整为最小30秒间隔');
            }
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            
            // 更新状态显示
            updateAutoRefreshStatus(false, 0);
            console.log('自动刷新已停止');
        }

        // 更新自动刷新状态显示
        function updateAutoRefreshStatus(enabled, interval) {
            const statusElement = document.getElementById('autoRefreshStatus');
            if (statusElement) {
                if (enabled) {
                    statusElement.innerHTML = `<span class="badge bg-success">已启用</span> <small class="text-muted">(${interval}秒间隔)</small>`;
                } else {
                    statusElement.innerHTML = `<span class="badge bg-secondary">已禁用</span>`;
                }
            }
        }

        // 防止重复保存的标志
        let isSavingWebRefreshConfig = false;
        let isSavingAutoMonitorConfig = false;
        
        // 保存Web自动刷新配置
        async function saveWebRefreshConfig() {
            if (isSavingWebRefreshConfig) {
                console.log('正在保存Web自动刷新配置，跳过重复请求');
                return;
            }
            
            isSavingWebRefreshConfig = true;
            
            try {
                const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                const autoRefreshInterval = document.getElementById('autoRefreshInterval');
                
                const enabled = autoRefreshToggle.checked;
                const interval = parseInt(autoRefreshInterval.value);
                
                console.log('保存Web自动刷新配置:', { enabled, interval });
                
                // 始终保存配置，无论启用还是禁用
                const response = await fetch('/api/config/web_refresh', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        enabled: enabled,
                        interval: interval
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('Web自动刷新配置保存成功');
                    console.log('配置详情:', data.data);
                    
                    // 更新状态显示
                    if (data.data && data.data.enabled) {
                        updateAutoRefreshStatus(true, data.data.interval);
                        showAlert('success', `自动刷新已启用，间隔: ${data.data.interval}秒`);
                    } else {
                        updateAutoRefreshStatus(false, 0);
                        showAlert('success', '自动刷新已禁用');
                    }
                    
                    // 不重新加载配置，避免无限循环
                    console.log('配置保存成功，跳过重新加载');
                } else {
                    console.error('保存Web自动刷新配置失败:', data.message);
                    showAlert('danger', '保存Web自动刷新配置失败: ' + data.message);
                }
            } catch (error) {
                console.error('保存Web自动刷新配置失败:', error);
                showAlert('danger', '保存Web自动刷新配置失败: ' + error.message);
            } finally {
                isSavingWebRefreshConfig = false;
            }
        }

        // 监控结果检查
        let monitorResultsInterval = null;

        function startMonitorResultsCheck() {
            if (monitorResultsInterval) {
                clearInterval(monitorResultsInterval);
            }
            monitorResultsInterval = setInterval(checkMonitorResults, 10000); // 10秒检查一次
            console.log('监控结果检查已启动');
        }

        function stopMonitorResultsCheck() {
            if (monitorResultsInterval) {
                clearInterval(monitorResultsInterval);
                monitorResultsInterval = null;
            }
            console.log('监控结果检查已停止');
        }

        async function checkMonitorResults() {
            try {
                console.debug('开始检查监控结果...');
                const response = await fetch('/api/monitor/last_results');
                const data = await response.json();
                
                console.debug('监控结果响应:', data);
                
                if (data.success) {
                    const results = data.data.last_results;
                    const monitoring = data.data.monitoring;
                    const auto_start_enabled = data.data.auto_start_enabled;
                    
                    if (results && results.length > 0) {
                        const successCount = results.filter(r => r.success).length;
                        const totalCount = results.length;
                        
                        console.log(`监控结果: 总数=${totalCount}, 成功=${successCount}`);
                        console.debug('详细结果:', results);
                        
                        if (successCount > 0) {
                            console.log(`自动监控执行完成：成功启动 ${successCount}/${totalCount} 个虚拟机`);
                            showAlert('success', `自动监控执行完成：成功启动 ${successCount}/${totalCount} 个虚拟机`);
                        } else if (totalCount > 0) {
                            console.warn(`自动监控执行完成：尝试启动 ${totalCount} 个虚拟机，但都失败了`);
                            showAlert('warning', `自动监控执行完成：尝试启动 ${totalCount} 个虚拟机，但都失败了`);
                        }
                    } else if (monitoring) {
                        // 状态监控模式
                        console.log('状态监控模式：仅监控虚拟机状态，不执行自动启动');
                        console.debug('监控状态:', { monitoring, auto_start_enabled });
                    }
                    
                    // 重新加载虚拟机列表以更新状态
                    console.debug('重新加载虚拟机列表...');
                    loadVMs();
                } else {
                    console.debug('没有新的监控结果');
                }
            } catch (error) {
                console.error('检查监控结果失败:', error);
                console.debug('错误详情:', error);
            }
        }

        // 监控控制
        async function startMonitoring(interval, autoStart = true) {
            try {
                console.log(`启动监控: 间隔=${interval}秒, 自动启动=${autoStart}`);
                console.debug('监控启动参数:', { interval, autoStart });
                
                // 确保参数类型正确
                interval = parseInt(interval);
                autoStart = Boolean(autoStart);
                
                // 记录启动时间戳
                const startTime = new Date().toISOString();
                console.debug('监控启动时间:', startTime);
                
                console.debug('参数验证后:', { interval, autoStart, startTime });
                
                const url = `/api/monitor/start?interval=${interval}&auto_start=${autoStart}&start_time=${encodeURIComponent(startTime)}`;
                console.debug('请求URL:', url);
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.debug('监控启动响应:', data);
                
                if (data.success) {
                    console.log('监控启动成功');
                    console.debug('监控状态更新');
                    
                    const startTimeText = data.start_time ? `，启动时间: ${new Date(data.start_time).toLocaleString()}` : '';
                    const modeText = autoStart ? '自动启动模式' : '状态监控模式';
                    
                    showAlert('success', `监控已启动，间隔${interval}秒，${modeText}${startTimeText}`);
                    document.getElementById('monitorStatus').textContent = '运行中';
                    document.getElementById('monitorMode').textContent = modeText;
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.add('monitoring-active');
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.remove('monitoring-inactive');
                    
                    // 启动监控结果检查
                    console.debug('启动监控结果检查');
                    startMonitorResultsCheck();
                } else {
                    console.error('监控启动失败:', data.message);
                    showAlert('danger', data.message);
                    document.getElementById('monitoringToggle').checked = false;
                }
            } catch (error) {
                console.error('启动监控失败:', error);
                console.debug('错误详情:', error);
                showAlert('danger', '启动监控失败: ' + error.message);
                document.getElementById('monitoringToggle').checked = false;
            }
        }

        async function stopMonitoring() {
            try {
                console.log('停止监控...');
                console.debug('发送停止监控请求');
                
                const response = await fetch('/api/monitor/stop');
                const data = await response.json();
                
                console.debug('停止监控响应:', data);
                
                if (data.success) {
                    console.log('监控停止成功');
                    console.debug('更新监控状态显示');
                    showAlert('success', data.message);
                    document.getElementById('monitorStatus').textContent = '已停止';
                    document.getElementById('monitorMode').textContent = '-';
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.remove('monitoring-active');
                    document.getElementById('monitorStatus').parentElement.parentElement.classList.add('monitoring-inactive');
                    
                    // 停止监控结果检查
                    console.debug('停止监控结果检查');
                    stopMonitorResultsCheck();
                } else {
                    console.error('停止监控失败:', data.message);
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error('停止监控失败:', error);
                console.debug('错误详情:', error);
                showAlert('danger', '停止监控失败: ' + error.message);
            }
        }

        // 加载监控状态
        async function loadMonitorStatus() {
            try {
                const response = await fetch('/api/monitor/status');
                const data = await response.json();
                
                if (data.success) {
                    const status = data.data.monitoring ? '运行中' : '已停止';
                    document.getElementById('monitorStatus').textContent = status;
                    
                    const statusElement = document.getElementById('monitorStatus').parentElement.parentElement;
                    if (data.data.monitoring) {
                        statusElement.classList.add('monitoring-active');
                        statusElement.classList.remove('monitoring-inactive');
                        document.getElementById('monitoringToggle').checked = true;
                    } else {
                        statusElement.classList.remove('monitoring-active');
                        statusElement.classList.add('monitoring-inactive');
                        document.getElementById('monitoringToggle').checked = false;
                    }
                }
            } catch (error) {
                console.error('加载监控状态失败:', error);
            }
        }

        // 更新最后更新时间
        function updateLastUpdate(timestamp) {
            document.getElementById('lastUpdate').textContent = formatTime(timestamp);
        }

        // 更新虚拟机数量
        function updateVMCount(count) {
            document.getElementById('vmCount').textContent = count;
        }

        // 显示提示消息
        function showAlert(type, message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(alertDiv);
            
            // 3秒后自动消失
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 3000);
        }



        // 加载VBOX_DIR配置
        async function loadVboxDirConfig() {
            try {
                const response = await fetch('/api/config/vbox_dir');
                const data = await response.json();
                
                if (data.success) {
                    const vboxDir = data.data.vbox_dir;
                    updateSelectedDirectoriesDisplay([vboxDir]);
                    console.log('VBOX_DIR配置:', vboxDir);
                } else {
                    console.error('获取VBOX_DIR配置失败:', data.message);
                    updateSelectedDirectoriesDisplay(['配置读取失败']);
                }
            } catch (error) {
                console.error('获取VBOX_DIR配置失败:', error);
                updateSelectedDirectoriesDisplay(['配置读取失败']);
            }
        }

        // 加载自动监控配置
        async function loadAutoMonitorConfig() {
            try {
                console.log('开始加载自动监控配置...');
                const response = await fetch('/api/config/auto_monitor');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    console.log('=== 自动监控配置调试信息 ===');
                    console.log('API返回的完整配置:', config);
                    console.log('enable_auto_monitoring:', config.enable_auto_monitoring);
                    console.log('button_enabled:', config.button_enabled);
                    console.log('auto_start_button_enabled:', config.auto_start_button_enabled);
                    console.log('interval_value:', config.interval_value);
                    console.log('default_interval:', config.default_interval);
                    console.log('================================');
                    
                    // 设置默认值
                    const monitoringToggle = document.getElementById('monitoringToggle');
                    const monitorInterval = document.getElementById('monitorInterval');
                    const autoStartToggle = document.getElementById('autoStartToggle');
                    
                    // 使用新的配置结构
                    console.log('使用新的配置结构');
                    
                    // 临时禁用change事件监听器，避免触发自动保存
                    const originalMonitoringHandler = monitoringToggle.onchange;
                    const originalAutoStartHandler = autoStartToggle.onchange;
                    monitoringToggle.onchange = null;
                    autoStartToggle.onchange = null;
                    
                    // 设置自动监控按钮状态
                    const monitoringEnabled = config.button_enabled || false;
                    monitoringToggle.checked = monitoringEnabled;
                    console.log('设置自动监控按钮状态:', monitoringEnabled);
                    
                    // 设置监控间隔
                    const intervalValue = config.interval_value || 30;
                    monitorInterval.value = intervalValue;
                    console.log('设置监控间隔:', intervalValue);
                    
                    // 设置自启动虚拟机按钮状态
                    const autoStartEnabled = config.auto_start_button_enabled || false;
                    autoStartToggle.checked = autoStartEnabled;
                    console.log('设置自启动虚拟机按钮状态:', autoStartEnabled);
                    
                    // 恢复change事件监听器
                    monitoringToggle.onchange = originalMonitoringHandler;
                    autoStartToggle.onchange = originalAutoStartHandler;
                    
                    // 不触发change事件，避免自动保存
                    console.log('配置加载完成，UI已更新');
                    
                    console.log('最终配置设置完成:', {
                        monitoring: monitoringToggle.checked,
                        interval: monitorInterval.value,
                        autoStart: autoStartToggle.checked
                    });
                    
                    // 如果自动监控已启用，启动监控
                    if (monitoringToggle.checked) {
                        console.log('自动监控已启用，启动监控...');
                        const interval = monitorInterval.value;
                        const autoStart = autoStartToggle.checked;
                        startMonitoring(interval, autoStart, false); // 不显示通知
                    } else {
                        console.log('自动监控未启用');
                    }
                } else {
                    console.error('获取自动监控配置失败:', data.message);
                }
            } catch (error) {
                console.error('获取自动监控配置失败:', error);
            }
        }

        // 加载Web自动刷新配置
        async function loadWebRefreshConfig() {
            try {
                console.log('开始加载Web自动刷新配置...');
                const response = await fetch('/api/config/web_refresh');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    console.log('=== Web自动刷新配置调试信息 ===');
                    console.log('API返回的完整配置:', config);
                    console.log('web_auto_refresh_enabled:', config.web_auto_refresh_enabled);
                    console.log('button_enabled:', config.button_enabled);
                    console.log('interval_value:', config.interval_value);
                    console.log('default_interval:', config.default_interval);
                    console.log('==================================');
                    
                    // 设置默认值
                    const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                    const autoRefreshInterval = document.getElementById('autoRefreshInterval');
                    
                    // 使用新的配置结构
                    console.log('使用新的配置结构');
                    
                    // 临时禁用change事件监听器，避免触发自动保存
                    const originalChangeHandler = autoRefreshToggle.onchange;
                    autoRefreshToggle.onchange = null;
                    
                    // 设置自动刷新按钮状态
                    const refreshEnabled = config.button_enabled || false;
                    autoRefreshToggle.checked = refreshEnabled;
                    console.log('设置自动刷新按钮状态:', refreshEnabled);
                    
                    // 设置自动刷新间隔
                    const refreshInterval = config.interval_value || 60;
                    autoRefreshInterval.value = refreshInterval;
                    console.log('设置自动刷新间隔:', refreshInterval);
                    
                    // 恢复change事件监听器
                    autoRefreshToggle.onchange = originalChangeHandler;
                    
                    // 更新状态显示
                    updateAutoRefreshStatus(autoRefreshToggle.checked, parseInt(autoRefreshInterval.value));
                    
                    // 不触发change事件，避免自动保存
                    console.log('Web自动刷新配置加载完成，UI已更新');
                    
                    // 如果自动刷新已启用，启动自动刷新
                    if (autoRefreshToggle.checked) {
                        console.log('Web自动刷新已启用，启动自动刷新...');
                        startAutoRefresh();
                    } else {
                        console.log('Web自动刷新未启用');
                    }
                } else {
                    console.error('获取Web自动刷新配置失败:', data.message);
                }
            } catch (error) {
                console.error('获取Web自动刷新配置失败:', error);
            }
        }

        // 更新单个配置参数
        async function updateConfigParameter(parameterName, value) {
            try {
                console.log(`更新配置参数: ${parameterName} = ${value}`);
                
                const response = await fetch('/api/config/update_parameter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        parameter: parameterName,
                        value: value
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log(`配置参数 ${parameterName} 更新成功`);
                    return Promise.resolve(data);
                } else {
                    console.error(`配置参数 ${parameterName} 更新失败:`, data.message);
                    showAlert('danger', `配置参数更新失败: ${data.message}`);
                    return Promise.reject(new Error(data.message));
                }
            } catch (error) {
                console.error(`更新配置参数 ${parameterName} 失败:`, error);
                showAlert('danger', `配置参数更新失败: ${error.message}`);
                return Promise.reject(error);
            }
        }

        // 保存自动监控配置
        async function saveAutoMonitorConfig() {
            if (isSavingAutoMonitorConfig) {
                console.log('正在保存自动监控配置，跳过重复请求');
                return;
            }
            
            isSavingAutoMonitorConfig = true;
            
            try {
                console.log('开始保存自动监控配置...');
                const monitoringToggle = document.getElementById('monitoringToggle');
                const monitorInterval = document.getElementById('monitorInterval');
                const autoStartToggle = document.getElementById('autoStartToggle');
                
                // 确保参数类型正确
                const enabled = Boolean(monitoringToggle.checked);
                const interval = parseInt(monitorInterval.value);
                const auto_start_enabled = Boolean(autoStartToggle.checked);
                
                console.log('准备保存的配置:', {
                    enabled: enabled,
                    interval: interval,
                    auto_start_enabled: auto_start_enabled
                });
                
                // 始终保存AUTO_MONITOR_BUTTON_ENABLED状态
                const enableResponse = await fetch('/api/config/update_parameter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        parameter: 'AUTO_MONITOR_BUTTON_ENABLED',
                        value: enabled
                    })
                });
                
                const enableData = await enableResponse.json();
                if (!enableData.success) {
                    console.error('保存AUTO_MONITOR_BUTTON_ENABLED失败:', enableData.message);
                    showAlert('danger', '保存自动监控状态失败: ' + enableData.message);
                    return;
                }
                
                // 只有在自动监控启用时才保存其他配置
                if (enabled) {
                    const config = {
                        enabled: enabled,
                        interval: interval,
                        auto_start_enabled: auto_start_enabled
                    };
                    
                    const response = await fetch('/api/config/auto_monitor', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(config)
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('自动监控配置保存成功');
                        showAlert('success', '自动监控配置已保存');
                    } else {
                        console.error('保存自动监控配置失败:', data.message);
                        showAlert('danger', '保存自动监控配置失败: ' + data.message);
                    }
                } else {
                    console.log('自动监控已禁用，ENABLE_AUTO_MONITORING已保存为False');
                    showAlert('success', '自动监控已禁用，配置已保存');
                }
            } catch (error) {
                console.error('保存自动监控配置失败:', error);
                showAlert('danger', '保存自动监控配置失败: ' + error.message);
            } finally {
                isSavingAutoMonitorConfig = false;
            }
        }



        // 加载选中的目录
        async function loadSelectedDirectories() {
            try {
                const response = await fetch('/api/config/get_directories');
                const data = await response.json();
                
                if (data.success) {
                    displaySelectedDirectories(data.data);
                } else {
                    console.error('获取选中目录失败:', data.message);
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error('加载选中目录失败:', error);
                showAlert('danger', '加载选中目录失败: ' + error.message);
            }
        }

        // 显示选中的目录
        function displaySelectedDirectories(directories) {
            const container = document.getElementById('selectedDirectoriesList');
            
            if (directories.length === 0) {
                container.innerHTML = '<p class="text-muted">暂无选中的目录</p>';
                return;
            }
            
            let html = '';
            directories.forEach((directory, index) => {
                html += `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2 border rounded">
                        <div class="flex-grow-1">
                            <div class="fw-bold">${directory}</div>
                            <small class="text-muted">虚拟机目录</small>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-info" onclick="scanDirectory('${directory}')" title="重新扫描">
                                <i class="fas fa-search"></i>
                            </button>
                            <button class="btn btn-outline-danger" onclick="removeDirectory(${index})" title="删除">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }









        // 更新选中目录显示
        function updateSelectedDirectoriesDisplay(directories) {
            const displayElement = document.getElementById('selectedDirectories');
            if (directories.length === 0) {
                displayElement.textContent = '未选择';
            } else {
                displayElement.textContent = directories.join(', ');
            }
        }



        // 启动失败标记管理
        let startFailureMap = new Map();

        // 标记启动失败
        function markStartFailure(vmName) {
            startFailureMap.set(vmName, {
                timestamp: new Date().toISOString(),
                count: (startFailureMap.get(vmName)?.count || 0) + 1
            });
            console.log(`标记虚拟机 ${vmName} 启动失败`);
        }

        // 清除启动失败标记
        function clearStartFailure(vmName) {
            startFailureMap.delete(vmName);
            console.log(`清除虚拟机 ${vmName} 启动失败标记`);
        }

        // 获取启动失败状态
        function getStartFailureStatus(vmName) {
            return startFailureMap.get(vmName) || null;
        }

        // 清除后端启动失败标记
        async function clearBackendStartFailure(vmName) {
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/clear_failure`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    console.log(`清除虚拟机 ${vmName} 后端启动失败标记成功`);
                } else {
                    console.error(`清除虚拟机 ${vmName} 后端启动失败标记失败:`, data.message);
                }
            } catch (error) {
                console.error(`清除虚拟机 ${vmName} 后端启动失败标记失败:`, error);
            }
        }

        // 清除虚拟机异常状态
        async function clearVMException(vmName) {
            try {
                showAlert('info', `正在清除虚拟机 ${vmName} 的操作异常标记...`);
                
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/clear_exception`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                
                if (data.success) {
                    showAlert('success', data.message);
                    // 重新加载虚拟机列表以更新显示
                    loadVMs();
                } else {
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error(`清除虚拟机异常状态失败: ${error}`);
                showAlert('danger', `清除虚拟机异常状态失败: ${error.message}`);
            }
        }

        // 清除虚拟机异常状态（静默模式，不显示提示）
        async function clearVMExceptionBackend(vmName) {
            try {
                const response = await fetch(`/api/vm/${encodeURIComponent(vmName)}/clear_exception`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                
                if (data.success) {
                    console.log(`已清除虚拟机 ${vmName} 的操作异常标记`);
                } else {
                    console.error(`清除虚拟机操作异常标记失败: ${data.message}`);
                }
            } catch (error) {
                console.error(`清除虚拟机操作异常标记失败: ${error}`);
            }
        }

        // 日志查看相关变量
        let logsUpdateInterval = null;
        let logsTerminal = null;
        let lastLogCount = 0;
        let isScrolledToBottom = true;
        let lastLogPosition = 0;
        let allLogs = [];

        // 显示日志查看模态框
        function showLogsModal() {
            console.log('显示日志查看模态框');
            const modal = new bootstrap.Modal(document.getElementById('logsModal'));
            modal.show();
            
            // 初始化日志终端
            logsTerminal = document.getElementById('logsTerminal');
            
            // 监听滚动事件
            logsTerminal.addEventListener('scroll', function() {
                const scrollTop = this.scrollTop;
                const scrollHeight = this.scrollHeight;
                const clientHeight = this.clientHeight;
                isScrolledToBottom = (scrollTop + clientHeight >= scrollHeight - 10);
            });
            
            // 开始实时更新日志
            startLogsUpdate();
        }

        // 开始日志更新
        function startLogsUpdate() {
            if (logsUpdateInterval) {
                clearInterval(logsUpdateInterval);
            }
            
            // 立即获取一次日志
            updateLogs();
            
            // 每1秒更新一次日志（更频繁的更新）
            logsUpdateInterval = setInterval(updateLogs, 1000);
        }

        // 停止日志更新
        function stopLogsUpdate() {
            if (logsUpdateInterval) {
                clearInterval(logsUpdateInterval);
                logsUpdateInterval = null;
            }
        }

        // 更新日志显示
        async function updateLogs() {
            try {
                // 使用日志流API获取新日志
                const response = await fetch(`/api/logs/monitor/stream?position=${lastLogPosition}&max_lines=100`);
                const data = await response.json();
                
                if (data.success && logsTerminal) {
                    const newLogs = data.data.logs;
                    const hasNewLogs = data.data.has_new_logs;
                    const currentPosition = data.data.position;
                    
                    // 如果是第一次加载，获取完整日志
                    if (lastLogCount === 0) {
                        const fullResponse = await fetch('/api/logs/monitor');
                        const fullData = await fullResponse.json();
                        if (fullData.success) {
                            allLogs = fullData.data.logs;
                            lastLogCount = allLogs.length;
                            lastLogPosition = data.data.file_size;
                        }
                    } else if (hasNewLogs && newLogs.length > 0) {
                        // 添加新日志到总日志列表
                        allLogs = allLogs.concat(newLogs);
                        lastLogCount = allLogs.length;
                        lastLogPosition = currentPosition;
                    }
                    
                    // 如果有新日志或者第一次加载，更新显示
                    if (lastLogCount > 0) {
                        // 更新日志显示
                        updateLogsDisplay();
                        
                        // 显示日志状态
                        const statusElement = document.getElementById('logsStatus');
                        if (statusElement) {
                            const updateTime = new Date().toLocaleTimeString();
                            
                            // 统计各级别日志数量
                            const levelCounts = {};
                            allLogs.forEach(log => {
                                const level = log.level.toLowerCase();
                                levelCounts[level] = (levelCounts[level] || 0) + 1;
                            });
                            
                            const statusText = hasNewLogs ? 
                                `共 ${lastLogCount} 行日志，有新日志，最后更新: ${updateTime} | DEBUG: ${levelCounts.debug || 0}, INFO: ${levelCounts.info || 0}, WARN: ${levelCounts.warning || 0}, ERROR: ${levelCounts.error || 0}` :
                                `共 ${lastLogCount} 行日志，最后更新: ${updateTime} | DEBUG: ${levelCounts.debug || 0}, INFO: ${levelCounts.info || 0}, WARN: ${levelCounts.warning || 0}, ERROR: ${levelCounts.error || 0}`;
                            statusElement.textContent = statusText;
                        }
                    }
                }
            } catch (error) {
                console.error('更新日志失败:', error);
                if (logsTerminal) {
                    const errorElement = document.createElement('div');
                    errorElement.className = 'text-danger';
                    errorElement.textContent = `日志更新失败: ${error.message}`;
                    logsTerminal.appendChild(errorElement);
                }
            }
        }

        // 复制日志
        function copyLogs() {
            if (logsTerminal) {
                const logsText = logsTerminal.innerText;
                navigator.clipboard.writeText(logsText).then(() => {
                    showAlert('success', '日志已复制到剪贴板');
                }).catch(() => {
                    showAlert('danger', '复制失败，请手动复制');
                });
            }
        }

        // 清空日志
        function clearLogs() {
            if (logsTerminal) {
                logsTerminal.innerHTML = '<div class="text-success">=== 日志已清空 ===</div>';
            }
        }

        // 日志过滤功能
        let currentLogFilter = 'all';
        
        function filterLogs(level) {
            currentLogFilter = level;
            updateLogsDisplay();
        }
        
        function updateLogsDisplay() {
            if (!logsTerminal || allLogs.length === 0) return;
            
            // 清空终端内容
            logsTerminal.innerHTML = '';
            
            // 根据过滤条件显示日志
            const filteredLogs = currentLogFilter === 'all' ? 
                allLogs : 
                allLogs.filter(log => log.level.toLowerCase() === currentLogFilter);
            
            // 添加过滤后的日志内容
            filteredLogs.forEach(log => {
                const logElement = document.createElement('div');
                logElement.className = `log-line ${log.level.toLowerCase()}`;
                
                // 根据日志级别设置颜色和样式
                switch(log.level.toLowerCase()) {
                    case 'error':
                        logElement.className += ' text-danger';
                        break;
                    case 'warning':
                        logElement.className += ' text-warning';
                        break;
                    case 'debug':
                        logElement.className += ' text-muted';
                        break;
                    case 'info':
                        logElement.className += ' text-info';
                        break;
                    case 'critical':
                        logElement.className += ' text-danger fw-bold';
                        break;
                    default:
                        logElement.className += ' text-light';
                        break;
                }
                
                // 如果有模块信息，添加模块标识
                if (log.module) {
                    const moduleSpan = document.createElement('span');
                    moduleSpan.className = 'text-primary fw-bold';
                    moduleSpan.textContent = `[${log.module}] `;
                    logElement.appendChild(moduleSpan);
                }
                
                // 添加日志消息
                const messageSpan = document.createElement('span');
                messageSpan.textContent = log.message;
                logElement.appendChild(messageSpan);
                
                logsTerminal.appendChild(logElement);
            });
            
            // 滚动到底部
            logsTerminal.scrollTop = logsTerminal.scrollHeight;
        }
        
        // 启动动态配置更新
        function startDynamicConfigUpdate() {
            console.log('启动动态配置更新...');
            
            // 每10秒检查一次配置更新，减少API调用频率
            configUpdateInterval = setInterval(async () => {
                // 只在页面可见时执行配置检查
                if (isPageVisible) {
                    try {
                        console.log('=== 执行定期配置检查 ===');
                        updateDynamicUpdateStatus('检查中...', '正在检查配置更新');
                        await checkAndUpdateConfigs();
                        updateDynamicUpdateStatus('运行中', '配置动态更新正常');
                    } catch (error) {
                        console.error('动态配置更新失败:', error);
                        updateDynamicUpdateStatus('错误', '配置动态更新失败');
                    }
                } else {
                    console.log('页面不可见，跳过配置检查');
                }
            }, 10000); // 增加到10秒间隔，减少API调用频率
            
            updateDynamicUpdateStatus('运行中', '动态配置更新已启动');
            console.log('动态配置更新已启动，每10秒检查一次');
        }
        
        // 停止动态配置更新
        function stopDynamicConfigUpdate() {
            if (configUpdateInterval) {
                clearInterval(configUpdateInterval);
                configUpdateInterval = null;
                updateDynamicUpdateStatus('已停止', '动态配置更新已停止');
                console.log('动态配置更新已停止');
            }
        }
        
        // 检查并更新配置
        async function checkAndUpdateConfigs() {
            try {
                const currentTime = Date.now();
                
                // 避免过于频繁的检查，最小间隔5秒
                if (currentTime - lastConfigUpdate < 5000) {
                    console.log('配置检查过于频繁，跳过本次检查');
                    return;
                }
                
                console.log('开始检查配置更新...');
                
                // 检查Web自动刷新配置
                await checkWebRefreshConfig();
                
                // 检查自动监控配置
                await checkAutoMonitorConfig();
                
                lastConfigUpdate = currentTime;
                updateConfigStatus('已同步', '配置动态更新正常');
                
                console.log('配置检查完成，所有配置已同步');
                
            } catch (error) {
                console.error('检查配置更新失败:', error);
                updateConfigStatus('同步失败', '配置动态更新失败');
            }
        }
        
        // 检查Web自动刷新配置
        async function checkWebRefreshConfig() {
            // 检查是否需要节流
            if (shouldThrottleAPI('checkWebRefreshConfig', 8000)) {
                return;
            }
            
            try {
                const response = await fetch('/api/config/web_refresh');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    const autoRefreshToggle = document.getElementById('autoRefreshToggle');
                    const autoRefreshInterval = document.getElementById('autoRefreshInterval');
                    
                    console.log('=== 检查Web自动刷新配置 ===');
                    console.log('配置文件状态:', {
                        button_enabled: config.button_enabled,
                        interval_value: config.interval_value
                    });
                    console.log('UI当前状态:', {
                        autoRefreshToggle: autoRefreshToggle.checked,
                        autoRefreshInterval: autoRefreshInterval.value
                    });
                    
                    let hasChanges = false;
                    
                    // 检查按钮状态是否需要更新
                    const currentButtonState = autoRefreshToggle.checked;
                    const configButtonState = config.button_enabled || false;
                    
                    if (currentButtonState !== configButtonState) {
                        console.log(`Web自动刷新按钮状态需要更新: 当前=${currentButtonState}, 配置=${configButtonState}`);
                        autoRefreshToggle.checked = configButtonState;
                        hasChanges = true;
                        
                        // 更新状态显示
                        updateAutoRefreshStatus(configButtonState, parseInt(autoRefreshInterval.value));
                        
                        // 如果状态变为启用，启动自动刷新
                        if (configButtonState && !currentButtonState) {
                            console.log('检测到自动刷新已启用，启动自动刷新...');
                            startAutoRefresh();
                        } else if (!configButtonState && currentButtonState) {
                            console.log('检测到自动刷新已禁用，停止自动刷新...');
                            stopAutoRefresh();
                        }
                    } else {
                        console.log('Web自动刷新按钮状态已同步');
                    }
                    
                    // 检查间隔值是否需要更新
                    const currentInterval = parseInt(autoRefreshInterval.value);
                    const configInterval = config.interval_value || 60;
                    
                    if (currentInterval !== configInterval) {
                        console.log(`Web自动刷新间隔需要更新: 当前=${currentInterval}, 配置=${configInterval}`);
                        autoRefreshInterval.value = configInterval;
                        hasChanges = true;
                        
                        // 如果自动刷新正在运行，重新启动以应用新间隔
                        if (autoRefreshToggle.checked) {
                            console.log('检测到间隔已更改，重新启动自动刷新...');
                            startAutoRefresh();
                        }
                    } else {
                        console.log('Web自动刷新间隔已同步');
                    }
                    
                    if (hasChanges) {
                        console.log('检测到Web自动刷新配置变化，更新UI状态');
                    }
                    
                    console.log('=== Web自动刷新配置检查完成 ===');
                }
            } catch (error) {
                console.error('检查Web自动刷新配置失败:', error);
            }
        }
        
        // 强制同步配置
        async function forceSyncConfig() {
            try {
                console.log('=== 强制同步配置开始 ===');
                updateConfigStatus('同步中...', '正在强制同步配置');
                
                // 立即重新加载所有配置
                await loadWebRefreshConfig();
                await loadAutoMonitorConfig();
                
                // 立即检查配置
                await checkWebRefreshConfig();
                await checkAutoMonitorConfig();
                
                updateConfigStatus('已同步', '强制同步配置完成');
                console.log('=== 强制同步配置完成 ===');
                
                // 显示成功提示
                showAlert('success', '配置强制同步完成');
                
            } catch (error) {
                console.error('强制同步配置失败:', error);
                updateConfigStatus('同步失败', '强制同步配置失败');
                showAlert('danger', '强制同步配置失败: ' + error.message);
            }
        }

        // 检查自动监控配置
        async function checkAutoMonitorConfig() {
            // 检查是否需要节流
            if (shouldThrottleAPI('checkAutoMonitorConfig', 8000)) {
                return;
            }
            
            try {
                const response = await fetch('/api/config/auto_monitor');
                const data = await response.json();
                
                if (data.success) {
                    const config = data.data;
                    const monitoringToggle = document.getElementById('monitoringToggle');
                    const monitorInterval = document.getElementById('monitorInterval');
                    const autoStartToggle = document.getElementById('autoStartToggle');
                    
                    console.log('=== 检查自动监控配置 ===');
                    console.log('配置文件状态:', {
                        button_enabled: config.button_enabled,
                        interval_value: config.interval_value,
                        auto_start_button_enabled: config.auto_start_button_enabled
                    });
                    console.log('UI当前状态:', {
                        monitoringToggle: monitoringToggle.checked,
                        monitorInterval: monitorInterval.value,
                        autoStartToggle: autoStartToggle.checked
                    });
                    
                    let hasChanges = false;
                    
                    // 检查自动监控按钮状态
                    const currentMonitoringState = monitoringToggle.checked;
                    const configMonitoringState = config.button_enabled || false;
                    
                    if (currentMonitoringState !== configMonitoringState) {
                        console.log(`自动监控按钮状态需要更新: 当前=${currentMonitoringState}, 配置=${configMonitoringState}`);
                        monitoringToggle.checked = configMonitoringState;
                        hasChanges = true;
                        
                        // 如果状态变为启用，启动监控
                        if (configMonitoringState && !currentMonitoringState) {
                            console.log('检测到自动监控已启用，启动监控...');
                            const interval = monitorInterval.value;
                            const autoStart = autoStartToggle.checked;
                            startMonitoring(interval, autoStart);
                        } else if (!configMonitoringState && currentMonitoringState) {
                            console.log('检测到自动监控已禁用，停止监控...');
                            stopMonitoring();
                        }
                    } else {
                        console.log('自动监控按钮状态已同步');
                    }
                    
                    // 检查监控间隔
                    const currentMonitorInterval = parseInt(monitorInterval.value);
                    const configMonitorInterval = config.interval_value || 30;
                    
                    if (currentMonitorInterval !== configMonitorInterval) {
                        console.log(`自动监控间隔需要更新: 当前=${currentMonitorInterval}, 配置=${configMonitorInterval}`);
                        monitorInterval.value = configMonitorInterval;
                        hasChanges = true;
                        
                        // 如果监控正在运行，重新启动以应用新间隔
                        if (monitoringToggle.checked) {
                            console.log('检测到监控间隔已更改，重新启动监控...');
                            const autoStart = autoStartToggle.checked;
                            startMonitoring(configMonitorInterval, autoStart);
                        }
                    } else {
                        console.log('自动监控间隔已同步');
                    }
                    
                    // 检查自启动虚拟机按钮状态
                    const currentAutoStartState = autoStartToggle.checked;
                    const configAutoStartState = config.auto_start_button_enabled || false;
                    
                    if (currentAutoStartState !== configAutoStartState) {
                        console.log(`自启动虚拟机按钮状态需要更新: 当前=${currentAutoStartState}, 配置=${configAutoStartState}`);
                        autoStartToggle.checked = configAutoStartState;
                        hasChanges = true;
                        
                        // 如果监控正在运行，重新启动以应用新设置
                        if (monitoringToggle.checked) {
                            console.log('检测到自启动设置已更改，重新启动监控...');
                            const interval = monitorInterval.value;
                            startMonitoring(interval, configAutoStartState);
                        }
                    } else {
                        console.log('自启动虚拟机按钮状态已同步');
                    }
                    
                    if (hasChanges) {
                        console.log('检测到配置变化，更新UI状态');
                        updateConfigStatus('已更新', '检测到配置变化并已同步');
                    }
                    
                    console.log('=== 自动监控配置检查完成 ===');
                }
            } catch (error) {
                console.error('检查自动监控配置失败:', error);
            }
        }
        
        // 更新配置状态显示
        function updateConfigStatus(status, message = '') {
            const configStatusElement = document.getElementById('configStatus');
            if (configStatusElement) {
                configStatusElement.textContent = status;
                configStatusElement.className = status === '已同步' ? 'text-success' : 'text-warning';
                if (message) {
                    console.log(`配置状态: ${status} - ${message}`);
                }
            }
        }
        
        // 更新动态更新状态显示
        function updateDynamicUpdateStatus(status, message = '') {
            const dynamicUpdateStatusElement = document.getElementById('dynamicUpdateStatus');
            if (dynamicUpdateStatusElement) {
                dynamicUpdateStatusElement.textContent = status;
                dynamicUpdateStatusElement.className = status === '运行中' ? 'text-success' : 
                                                    status === '已停止' ? 'text-warning' : 'text-danger';
                if (message) {
                    console.log(`动态更新状态: ${status} - ${message}`);
                }
            }
        }
        
        // 重新加载所有配置
        async function reloadAllConfigs() {
            console.log('重新加载所有配置...');
            updateConfigStatus('同步中...', '正在重新加载配置');
            
            try {
                await loadWebRefreshConfig();
                await loadAutoMonitorConfig();
                console.log('所有配置重新加载完成');
                updateConfigStatus('已同步', '配置重新加载完成');
                showAlert('success', '配置重新加载完成');
            } catch (error) {
                console.error('重新加载配置失败:', error);
                updateConfigStatus('同步失败', '配置重新加载失败');
                showAlert('danger', '配置重新加载失败: ' + error.message);
            }
        }
        
        // 模态框关闭时停止日志更新
        document.getElementById('logsModal').addEventListener('hidden.bs.modal', function() {
            stopLogsUpdate();
        });
        
        // 页面卸载时清理定时器
        window.addEventListener('beforeunload', function() {
            stopDynamicConfigUpdate();
            console.log('页面卸载，清理动态配置更新定时器');
        });

        // 在加载虚拟机列表时添加启动失败标记
        function addStartFailureMarkers(vmList) {
            vmList.forEach(vm => {
                // 检查后端返回的启动失败信息
                if (vm.start_failure) {
                    // 同步到前端缓存
                    startFailureMap.set(vm.name, {
                        timestamp: vm.failure_timestamp,
                        count: vm.failure_count
                    });
                }
                
                // 检查前端缓存的失败信息
                const failureStatus = getStartFailureStatus(vm.name);
                if (failureStatus) {
                    vm.start_failure = true;
                    vm.failure_count = failureStatus.count;
                    vm.failure_timestamp = failureStatus.timestamp;
                }
            });
        }

        // 清除所有启动失败标记
        async function clearAllStartFailures() {
            try {
                const response = await fetch('/api/vm/clear_all_failures', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('清除所有启动失败标记成功');
                    showAlert('success', data.message);
                    startFailureMap.clear(); // 清除前端缓存
                    loadVMs(); // 重新加载虚拟机列表以更新显示
                } else {
                    console.error('清除启动失败标记失败:', data.message);
                    showAlert('danger', data.message);
                }
            } catch (error) {
                console.error('清除启动失败标记失败:', error);
                showAlert('danger', '清除启动失败标记失败: ' + error.message);
            }
        }

        // 退出登录
        async function logout() {
            if (confirm('确定要退出登录吗？')) {
                try {
                    const response = await fetch('/logout', {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        window.location.href = '/login';
                    } else {
                        showAlert('danger', '退出失败');
                    }
                } catch (error) {
                    console.error('退出失败:', error);
                    showAlert('danger', '退出失败: ' + error.message);
                }
            }
        }
    </script>
</body>
</html> 